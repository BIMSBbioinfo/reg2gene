---
title: "reg2gene"
author: "Inga Patarcic"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{reg2gene}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r global_options, include=FALSE}

library(knitr)

opts_chunk$set(warning = FALSE,
               message= FALSE,
               fig.align='center',
               fig.path='Figures', 
               dev='png',
               fig.show='hold', 
               cache=FALSE)

library(reg2gene)
library(InteractionSet)
library(GenomicRanges)
```


# INTRODUCTION:

This document describes __reg2gene__ - an R package which can be used to 
predict the target genes for regulatory elements genome-wide. 


To link enhancer activity and gene expression __reg2gene__ functions __correlate__ and/or use other statistical approaches (__elastic net__ and __random forests__)  to model __ gene expression ~ enhancer activity __ across different cell types. This approach is based on the observation that enhancers show very high tissue specificity and the level of their activity correlates with gene expression (Visel et al. 2009., Ernst et al. 2011).


All analyses can be done easily for different types of enhancer-related
chromatin marks ( __H3K4me1__, __H3K27ac__, __DNA methylation__, __DHS__, etc.) and for different sources of data (Roadmap, Blueprint or in-house datasets).
Single-model information (gene-enhancer pairs) can be aggregated by means of 
__meta-analysis__ across different data-sources or by __majority voting__
decisions across both different modelling procedures or different data-types,
e.g.chromatin marks.



To __benchmark__ reported associations, external benchmark dataset can be used to
identify overlapping pairs in the genome (predicted gene~enhancer pairs that
overlap in location with benchmark pair), whereas __confusion matrix__ can be 
calculated to assess performance of the modelling procedure based on the used
external benchmark dataset. Often, information about the 3D genome architecture,
generated by chromosome conformation capture and related techniques, can be 
used as a proxy of enhancer-mediated regulation of gene expression 
(Dekker  et al. 2002, Dosie et al. 2006, Simonis et al. 2006, Fullwood et al. 
2009, Lieberman-Aiden et al. 2009), and thus can represent a good benchmark 
dataset __to benchmark results__ of reg2gene modelling approach.



To achieve aforementioned functionality, this package gathers functions that:

    * a) quantify gene expression and enhancer activity based on input 
    bigwig files: regActivity() , bwToGeneExp() ,regActivityAroundTSS(),

    * b) model and test quantified gene expression ~ enhancer activity 
    associations: associateReg2Gene(),
    
    * c) combine different models in terms of meta-association or majority
    voting decisions: metaAssociations(), voteAssociations()
    
    * d) benchmark reported associations with predefined benchmark dataset:
    benchmarkGI()
    
    * e) assess modelling performance via calculating and reporting confusion 
    matrix for tested benchmarked dataset: confusionMatrix(). 





# Data input 

## INPUT DATA TYPE 1: GRanges objects

This package comes with 2 toy datasets, GRanges objects:

GRReg1_toy 

```{r, echo=FALSE}
reg2gene::GRReg1_toy
```
and GRReg2_toy

```{r}
reg2gene::GRReg2_toy
```

with genome locations preselected in such way that all possible outputs
ofthe  benchmarking procedure is captured. 


*Colums which correspond to the expected outcome of the benchmarking procedure
are: 

Bench1Exp,

Filter2Exp,

Bench2Exp,

Filter1Exp

 


Where Bench1 andFilter1 corresponds to the benchmarking of GRReg1_toy with 
GRReg2_toy, whereas Bench2 and Filter2 corresponds to the benchmarking of 
GRReg1_toy with itself.



For example,following object 
```{r}
reg2gene::GRReg1_toy[7]
```
is benchmarked 3 times with  GRReg2_toy

```{r}
GRReg2_toy[10:12]
```

## INPUT DATA TYPE 2: .bigWig files as an input

A second necesarry argument for quantification functions is a named list of 
BigWig file paths is used as an input to link bigwig locations.

As example shows:

```{r}
test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")

regActivityInputExample <- c(test.bw,test2.bw)  

regActivityInputExample

```


## INPUT DATA TYPE 3: GInteractions objects

Input data for quantification functions are GRanges objects. 

However, modelling procedure outputs, by default, GInteractions object from the 
InteractionSet package. 

### Introducing a GInteractions object

Toy or any other GRanges objects can be easily organized as GInteractions 
objects:

```{r}
  
    GRReg1_toyGI <- GRReg1_toy
    
    GRReg1_toyGI <- GInteractions(GRReg1_toyGI,GRReg1_toyGI$reg)

  GRReg1_toyGI[1:3]

```





---




# 1. Quantification and data integration  


__QUANTIFICATION:__
Before running a modelling analysis, for genes and enhancers of interest, both,
geneexpression and enhancer activity need to be quatified (and normalized). 


__Data integration:__
Afterwards, all enhancers and their activities need to be stored in the GRanges 
object together with gene of interest and its calculated expression levels
(look below at 1c)

## Schematic representation of quantification and data integration:

```{r fig2, fig.height = 5, fig.width = 3, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/QuantificationDataIntegrationSimplified.png")
```

---

### 1a. Quantifying gene expression using bwToGeneExp()


---

To quantify gene expression a bwToGeneExp() can be used.
In short, this function firstly quantifies __exon expressions__ over pre-defined 
exon regions using signal from RNA-Seq tracks (bigwig files), then it sums over 
all exons of a gene of interest to obtain levels of __gene expression__.
With this function, gene expression levels can be quantified over a set of 
samples, cell types or conditions (list of .bigWig files).



__IN DETAIL:__
For a gene of interest and across all input samples (.bw files) individaully,the 
expression is firstly calculated for all exon regions definded in the input 
GRanges object (exons argument, details below). 
For quantificatons of enhancer activity over this exon regions, 
a ScoreMatrixBin() from the genomation package is used. 


This is followed by per gene expression quantification as follows:

___

$Gene Expression=\sum_{i=1}^n (Exon Expression_n * ExonLength_n)/(GeneLength)$


$GeneLength=\sum_{i=1}^n ExonLength_n$

___
 
e.g. mean exon expression scores are multiplied by the exon length,summed 
together and divided by the gene length(a sum of all exon lengths for that gene)
After quantifying gene expression, a normalization step ("quantile" or "ratio")
can be runned.

NOTES:
This function might be extended to work with BAM files in the future, 
however now it works only with relevant .bigWig files
RNA-Seq .bw files can originate from stranded,unstranded or mixed libraries.

###__bwToGeneExp() OUTPUT:__

When quantification using bwToGeneExp() is performed using toy examples 
of input GRanges objects (regTSS_toy) and a list of bigWig files
(regActivityInputExample) a following result is obtained:

```{r}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3,5,5,5))
                                        
                                        
 bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw))


```

For each gene, information is quantified first across exons and then summed per gene to quantify gene expression levels.

In the following toy example there are 3 genes: TEST_Reg1, TEST_Reg3 and
TEST_Reg5 with different number of exons:

TEST_Reg1 has 2 exons,

TEST_Reg3 has 1 exons,

TEST_Reg3 has 5 exons,


Notice that output GRanges object now has 3 genomic ranges reported which 
correspond to the toy genes analyzed: TEST_Reg1,TEST_Reg3 and TEST_Reg5.
For these genes TSS is location is reported in the genomic ranges object.

Additionally, if exons input is of GInteractions class object, 
the same output GRanges object is obtained: 

```{r,echo=FALSE}

require(InteractionSet)

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
 test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
 
 regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                       IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                             c(rep("+",3),rep("-",3)))
  regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
  regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",c(1,1,3,5,5,5))
 
 # if exons input is of GInteractions class object, the same output is obtained
 
 exons= GInteractions(regTSS_toy,regTSS_toy$reg)
    exons$name=regTSS_toy$name
    exons$name2=regTSS_toy$name2
    
     exons
   
     print("Which results in:")
     
    bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw))

```



__INPUT DATA DETAIL description (min arguments):__

####__1. exons__
Information about exon and gene coordinates should be a GInteractions object 
from the InteractionSet package, with Anchor1 representing the exon locations, 
and Anchor2 represents location of the corresponding gene. 

```{r,echo=FALSE}

  require(InteractionSet)

    GRReg1_toyGI <- reg2gene::GRReg1_toy[1]
    
    GRReg1_toyGI <- GInteractions(GRReg1_toyGI,GRReg1_toyGI$reg)

    mcols(GRReg1_toyGI) <- mcols(GRReg1_toyGI)[1:3]

GRReg1_toyGI

```

Optionally, the input GRanges object that contains exon regions over which the 
expression will be calculated needs to contain a meta-data columns with the 
following information:

    1) reg - GRanges object - corresponding gene location, or TSS location.
    2) name (character)- ENSEMBL or other gene identifier; 
    3) name2(character,optional) - 2nd gene identifier, 

Example:  
    
```{r,echo=FALSE}
  
    toy <- reg2gene::GRReg1_toy[1]
    mcols(toy) <- mcols(toy)[1:3]
    toy

```

It is strongly suggested to adjust seqlengths of this object to be equal to the seqlenghts *Hsapiens* from the appropriate package (BSgenome.Hsapiens.UCSC.hg19 or whatever needed version).


####__2. geneActSignals__

A second necesarry argument for quantification functions is a named list of BigWig file paths is used as an input to link bigwig locations.

As example shows:

```{r}

require(reg2gene)

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")

regActivityInputExample <- c(test.bw,test2.bw)  

regActivityInputExample

```


__INPUT DATA DETAIL description (additional arguments):__ 

####sampleIDs argument

Additional argumets in  bwToGeneExp() adjust for names of RNA-Seq libraries (argument __sampleIDs__); whether stranded or/and unstranded libraries are included, normalization procedure and parallel processing.

For example, __sampleIDs__ by defult uses basenames of the paths for input 
.bigWig files as a unique sample ids/names. However, a vector of unique sample ids/names(.bw files) can be used as well. It is necessary that values in this vector are ordered as the .bigWig file paths are.  The previous toy example unique sample ids:test and test2 can be modified with the sampleIDs argument to __CellType__ and __CellType2__ as follows:

```{r}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3,5,5,5))
                                        
                                        
 bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw),
       sampleIDs=c("CellType1","CellType2"))


```

####libStrand argument

RNA-Seq stranded and unstranded libraries allowed. BUT!!! It is crucial that forward and reverse RNA-Seq libraries are listed in one on top of other.
For example, 

```{r}

sampleIDs <- c("/Reverse1.bw","/Forward1.bw","/Reverse2.bw","/Forward2.bw",
               "Unstranded1")

sampleIDs
```
needs to be accompanied with 
```{r}
libStrand <- c("+","-","+","-","*")

libStrand

```


##### Other arguments for bwToGeneExp():normalize, summaryOperation and mc.cores 

#### Normalization procedure:

Normalization procedure in not performed by default but 2 normalizations can
be optionally used:a) __"quantile"__ 
```{r,echo=FALSE}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3,5,5,5))
                                        
        
print("bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw),
             normalize=\"quantile\")")
                                
 bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw),
             normalize="quantile")
       
```
If normalize argument is set to be "quantile" activity measures are 
__quantile normalized__ as implemented in the normalize.quantiles() from 
preprocessCore package.


and b) __"ratio"__

```{r,echo=FALSE}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3,5,5,5))

print("bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw),
             normalize=\"ratio\")")                                  
                                        
 bwToGeneExp(exons = regTSS_toy,geneActSignals = c(test.bw,test2.bw),
             normalize="ratio")
       
```
If normalize argument is set to be"ratio" then __"median ratio method"__ 
implemented as estimateSizeFactorsForMatrix from DESeq2 package is used to
normalize activity measures. 
__NOTE__: Normalization is runned on the level of gene expression. 





#### summaryOperation:

This argument designates which summary operation should be used over the regions Currently, only "mean" is available, but "median" or "sum" will be implemented in the future.

####mc.cores
As in the bwToGeneExp(),an option for parallel processing using mclapply from parallel package.



---

### 1b. Quantifying enhancer activity - regActivity()

---

Enhancer activity can be quantified based on the bigWig tracks of ChIP-Seq
signals for histone modifications (such as H3K27ac and H3K4me1, but for any other histone modification as well), of DNase-seq signals and of 
bisulfite-sequencing results for DNA methylation for any pre-defined 
GRanges object which contains info about enhancer regions in the genome.

To quantify enhancer activity __regActivity()__ is used, and this funcion
performs across a set of samples.

__IN DETAIL:__
For a regulatory regions of interest and across all input samples (.bw files) individaully the activity is calculated using ScoreMatrixBin() from the genomation package. Regulatory activity is measured by averaging logFC for histone modification ChIP-seq profiles, or DNAse signal, or DNA methylation per base. A before, relevant bigWig files are required to calculate activity,but function might be extended to work with BAM files
in the future. 

An output of a function is a GRanges object where its meta-columns correspond to the calculated activity levels per input sample. Column names correspond to provided sample ids or names.

###__regActivity() OUTPUT:__


```{r}
test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",4),rep("chr2",2)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3:6)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3:length(regTSS_toy)))
regActivity(regTSS_toy,c(test.bw,test2.bw))   

```


__INPUT DATA DETAIL description (min arguments):__

To run this function, minimaly regRegions GRanges object, and a list
of paths to .bigwig files must be used as an input. 


####regRegions

regRegions argument corresponds to a GRanges object which contains regulatory regions in the genome over which the regulatory activity will be calculated. It is strongly suggested to adjust seqlengths of this object to be equal to the __seqlenghts of Hsapiens__ from the appropriate package (BSgenome.Hsapiens.UCSC.hg19 or whatever needed version).
Example:

```{r,echo=FALSE}

regTSS_toy <- GRanges(c(rep("chr1",4),rep("chr2",2)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3:6)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3:length(regTSS_toy)))


regTSS_toy   

```


####activitySignals

A second necesarry argument for regActivity quantification function is a named list of BigWig file paths is used as an input to link bigwig locations. This argument corresponds to the __geneActSignals__ argument in bwToGeneExp(). 

Take a look at the example for this argument at __geneActSignals__ argument in bwToGeneExp().



##### Other arguments for regActivity():normalize, summaryOperation and mc.cores 

####sampleIDs argument

As in the bwToGeneExp(), this argument adjusts for names of CHiP-Seq libraries. It by defult uses basenames of the paths for input .bigWig files as a unique sample ids/names. However, a vector of unique sample ids/names(.bw files) can be used as well. It is necessary that values in this vector are ordered as the .bigWig file paths are. 
Take a look at the example for this argument at __sampleIDs__ argument in bwToGeneExp()


#### Normalization procedure:

As in the bwToGeneExp(), normalization procedure in not performed by default but 2 normalizations can be optionally used: __"quantile"__ and __"ratio"__. If normalize argument is set to be "quantile" activity measures are __quantile normalized__ as implemented in the normalize.quantiles() frompreprocessCore package.
If normalize argument is set to be"ratio" then __"median ratio method"__ implemented as estimateSizeFactorsForMatrix from DESeq2 package is used to normalize activity measures. 

Take a look at the example for this argument at __normalize__ argument in bwToGeneExp().

#### summaryOperation:

As in the bwToGeneExp(), this argument designates which summary operation should be used over the regions .Currently, only "mean" is available, but "median" or "sum" will be implemented in the future.

####mc.cores
As in the bwToGeneExp(),an option for parallel processing using mclapply from parallel package.


__regActivity() specific parameters:__

####isCovNA 
This parameter is important when dealing with DNA methylation datasets, where uncovered bases in bigWig files do not mean zero methylation. When this is set to TRUE, uncovered bases are set to NA.

[Examples.]

###weightCol 
This parameter is important when genomic regions have scores other than their 
coverage values, such as percent methylation, conservation scores, GC content, etc.
When used, a numeric column in the meta data is used as weights. 


[Examples.]

---

### 1c. Identifying enhancers located within certain window from TSS  - regActivityAroundTSS()

---

This package allows to test all enhancers within certain range from the 
TSS (transcriptional start site) of a gene (by default it is +/-1Mb). 
It is done using __regActivityAroundTSS()__.

This is important since many enhancers do not necessarily regulate the closest gene (Mifsud et al. 2015, Schoenfelder et al 2015, Javierre et al. 2016), but they bypass nearby genes while forming long-range interactions with targeted promoters (Tolhuis et al. 2002, Lettice et al. 2003) and vice-versa, genes are commonly regulated by more than one enhancer region (Tolhuis et al. 2002).

__IN DETAIL__


The function identifies the regulatory regions around provided TSSes over a pre-defined window (+/-1Mb) as shown: 


###__regActivityAroundTSS() OUTPUT:__

```{r}

regTSS_toy <- GRReg1_toy
  regTSS_toy$bw1 <- rep(1,length(GRReg1_toy))
  regTSS_toy$bw2 <- rep(2,length(GRReg1_toy))
  regTSS_toy$bw3 <- rep(3,length(GRReg1_toy))
regReg_toy <- GRReg2_toy
   regReg_toy$bw1 <- rep(3,length(regReg_toy))
   regReg_toy$bw2 <- rep(4,length(regReg_toy))

regActivityAroundTSS(regReg_toy,regTSS_toy,upstream=1,downstream=1)


```

An output of __regActivityAroundTSS()__ is a GRangesList object that contains per
gene GRanges with location of the corresponding TSS and regulatory regions 
identified around that gene. Names for the GRangesList are unique gene ids/names. It previous example there are 3 genes: TEST_Reg1, TEST_Reg2, TEST_Reg3 so GRanges in GRangesList object are named accordingly.
Metadata for each GRanges object in the GRangesList represents regulatory activity and gene expression quantified across a number of samples (.bw files)  that have matched IDs in RNA-Seq and CHiP-Seq,DNase-Seq or bisulfite sequencing experiment. 
The GRanges objects have the following metadata columns:
     
     1. featureType: either "gene" or "regulatory" 
     2. name: name/id for gene and enhancers. Gene name could be id from a database enhancer name should be in the format as follows "chr:start-end" 
     3. name2: a secondary name for the feature, such as gene symbol "PAX6" etc. not necessary for enhancers could be NA 
     4. other columns: numeric values for gene expression or regulatory actvity. Column names represent sample names/ids


Importantly, only enhancers located within predefined (+/-) upstream/downstream 
regions of TSS are identified, extracted and reported in output (together with info about gene expression). 

!!!
Sample id's (corresponding to the cell types or conditions) are included in output object only if both, 1) gene expression 
values and 2) quantified regulatory activity are available in TSS and regActivity objects. Non-overlapping cell types are excluded.



__INPUT DATA DETAIL description (min arguments):__

To run this function, minimaly __tss__ GRanges object (a GRanges object with TSSes and meta-columns corresponding to expression levels across different cell types or conditions;
an output of the bwToGeneExp()), and __regActivity__ the result of  the regActivity() - 
a GRanges object with enhancer locations and quantified enhaner activity need to
be used as an input. 


##### Other arguments for regActivity()

####upstream,downstream
number of basepairs upstream/downstream from TSS to look for regulatory regions. 

```{r, echo=FALSE}

regTSS_toy <- GRReg1_toy
  regTSS_toy$bw1 <- rep(1,length(GRReg1_toy))
  regTSS_toy$bw2 <- rep(2,length(GRReg1_toy))
  regTSS_toy$bw3 <- rep(3,length(GRReg1_toy))
regReg_toy <- GRReg2_toy
   regReg_toy$bw1 <- rep(3,length(regReg_toy))
   regReg_toy$bw2 <- rep(4,length(regReg_toy))

   
   print("Result of upstream=5,downstream=5")
regActivityAroundTSS(regReg_toy,regTSS_toy,upstream=5,downstream=5)[1]


```

####mc.cores
As in the bwToGeneExp(),an option for parallel processing using mclapply from parallel package.

---

# 2. Modelling gene expression~enhancer activity + integrating different algorithms and data sources

---

## 2a. Modelling gene expression~enhancer activity

---

As previously mentioned linking gene expression and enhancer activity in __reg2gene__ package is based on __correlation__ and/or __elastic net__, __random forests__ modelling of __ gene expression ~ enhancer activity __ across different cell types. 

This functionality is obtained with one function: __associateReg2Gene__
which associates/links regulatory regions to genes based on regulatory activity and gene expression relationship.


__IN DETAIL__

The function implements four methods to associate regulatory activity to genes:

    correlation (Pearson and/or Spearman), 
    
    distance correlation ("dcor"), 
    
    elasticnet and
    
    random forests. 
    
__Correlation__ is implemented to capture linear individual enhancer~gene relationships. Likewise, simple linear regression on scaled data is equivalent to Pearson correlation.


__Distance correlation__ is a metric for statistical dependence between two variables. It can capture non-linear relationships different from correlation.

__Elasticnet__ and __randomForests__ are methods that can capture additivity between regulatory activities and their relationship to gene expression. 
For details about these methods take a look at:


For all the methods, __P-values__ are estimated by __shuffling__ the gene expression vector __B times__ and getting a null distribution for the estimated statistic, and comparing the original statistic to the null distribution. Estimated statistics are __correlation coefficients__ for correlation and distance correlation methods, regression coefficients for elasticnet and __gini importance__ scores for random forests. P-values from resampling statistics are estimated using Gamma distribution, e.g. gamma distribution based P-values from the null distribution are obtained from resampling (gamma distribution is fit to the null distribution and p-values are calculated based on that fitted distribution).

An output of this function is  GInteraction object containing every potential association and between a regulatory region and TSS, and the estimated association statistic: its P-values and Q-values.

###__associateReg2Gene() OUTPUT:__

For the output of regActivityAroundTSS() object

```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation
 
 require(GenomicRanges)
 require(doMC)
 require(glmnet)
 require(foreach)
 require(stringr)
 require(qvalue)
 
 ####################################
 # create example
 
 x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
      2.599857,4.216959,2.589133,1.848172,3.039659)
 y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
      5.048476,2.884551,2.780067,4.053136)
 corrM <- rbind(x,y)
 
 # define Granges object
  gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))
    
    GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

        colnames(GeneInfo) <- c("featureType","name","name2")

       mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))
 
 
       gr0
       
    
```

Run associateReg2Gene() as follows

```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation
 
 require(GenomicRanges)
 require(doMC)
 require(glmnet)
 require(foreach)
 require(stringr)
 require(qvalue)
 
 ####################################
 # create example
 
 x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
      2.599857,4.216959,2.589133,1.848172,3.039659)
 y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
      5.048476,2.884551,2.780067,4.053136)
 corrM <- rbind(x,y)
 
 # define Granges object
  gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))
    
    GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

        colnames(GeneInfo) <- c("featureType","name","name2")

       mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))
 
    print("associateReg2Gene(gr0,cores = 1,B=100)")
    associateReg2Gene(gr0,cores = 1,B=100)     
   
```


This example was created to have correlation between gene expression
and enhancer activity equal to 0.8. This estimated association statistic is 
reported as __coefs__ and is recalculated as 0.8. Associated P-values are
calculated in and reported as __pval__.
Corresponding __qval__ is calculated. However, q-values are set
to be NA since, this toy example contains only one gene~enhancer pair, 
thus one p-value is calculated but q-values cannot be calculated based on only 
one p-value.



__INPUT DATA DETAIL description (min arguments):__

####Input
a GRangesList that contains regulatory activity and gene expression 
results. It has to have specific columns, see above example

####method
Modelling method of choice: pearson,spearman,dcor,elasticnet,
 or randomForest. By default it is set to be: "pearson". See Details for more.
 

__INPUT DATA DETAIL description (associateReg2Gene() specific arguments):__
 
####scaleData
if TRUE (default) the the values for gene expression and regulatory activity will be scaled to have 0 mean and unit variance using base::scale function.

####cores
An option for parallel processing using mclapply from parallel package.


####B
number of randomizations used to estimate P-values for coefficients returned by different methods.
default 1000

####asGInteractions 
if TRUE (default) results are reported as GInteractions. Otherwise, a GRanges object with regulatory region coordinates and an additional column "reg" containing gene GRanges is reported


OUTPUT as GRanges: 
```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation
 
 require(GenomicRanges)
 require(doMC)
 require(glmnet)
 require(foreach)
 require(stringr)
 require(qvalue)
 
 ####################################
 # create example
 
 x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
      2.599857,4.216959,2.589133,1.848172,3.039659)
 y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
      5.048476,2.884551,2.780067,4.053136)
 corrM <- rbind(x,y)
 
 # define Granges object
  gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))
    
    GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

        colnames(GeneInfo) <- c("featureType","name","name2")

       mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))
 
    print("associateReg2Gene(gr0,cores = 1,B=100)")
    associateReg2Gene(gr0,cores = 1,B=100,asGInteractions=FALSE)     
   
```


Importantly, this function does not report statistically significant 
gene-enhancer associations, whereas it reports all input gene-enhancer associations and corresponding test statistics. It is up to researcher to decide
which gene-enhancer associations they consider to be statistically significant
pairs.



---

## 2b. Integrating different algorithms and data sources via voteAssociations()


---

__IN DETAIL__

Since __associateReg2Gene()__ analysis can be done easily for different types of enhancer-related chromatin marks ( __H3K4me1__, __H3K27ac__, __DNA methylation__, __DHS__, etc.) and for different sources of data (Roadmap, Blueprint or in-house datasets) by using __voteAssociations()__ results of all these analyses can be aggregated - by __majority voting__ decisions across either different modelling algorithms ( __dcor__, __pearson__, __elasticnet__, etc.) or different data-types ( __H3K4me1__, __H3K27ac__, __DNA methylation__, __DHS__, etc.)


## Schematic representation of majority voting:

```{r fig3, fig.height = 5, fig.width = 5, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/master/vignettes/Figures/VOTING.png")

```

Thus, multiple associations output by different methods and data sets can be merged this way, and only the associations that have support in __vote.threshold__ fraction of the datasets will be retained. 

For example, retain only gene-enhancer pairs that are supported by modelling __reg2gene__ analysis using both __H3K4me1__ and __H3K27ac__ to quantify enhancer activity. Or, retain only gene-enhancer pairs that are supported by modelling __reg2gene__ analysis using  __pearson__, __spearman__ and __elasticnet__ algorithms.


First, __voteAssociations()__ selects POSITIVES (statistically associated gene~enhancer pairs) 
for each result of __associateReg2Gene()__ analysis that wants to be combined by  __majority voting__ (for example results of __H3K4me1__ and __H3K27ac__ __associateReg2Gene()__ analysis). 

Assessing statistically associated gene-enhancer pairs has been done by filtering the statistics (__cutoff.stat__) of the elements of the input list (gene-enhancer pairs) based on the defined cutoff value (__cutoff.val__). 


__voteAssociations() OUTPUT:__

is GInteractions object with gene~enhancer interactions voted above predefined threshold (reported as __votes__ column).
```{r, echo=FALSE}

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 associations <- list(AssocObject,AssocObject2)
 names(associations) <- c("H3K4me1","H327ac")
 
 # Run voteAssociations
 voteAssociations(associations, 
                  cutoff.stat="pval",
                  cutoff.val=0.05,
                  vote.threshold=0.5)
                  
```

By defult then following command was runned:
voteAssociations(associations, cutoff.stat = "pval", cutoff.val = 0.05, vote.threshold = 0.5) 
And this example was based on the following input data:

__INPUT DATA DETAIL description (min arguments):__

####associations	

A list of GInteractions objects outputed from __associateReg2Gene()__ or __metaAssociations()__, as shown:

```{r, echo=FALSE}
require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 associations <- list(AssocObject,AssocObject2)
 names(associations) <- c("H3K4me1","H327ac")

 associations
```
 
Since __vote.threshold__ was set to be 0.5, then both gene examples passed __majority voting__
procedure.
 
However,

__INPUT DATA DETAIL description (voteAssociations() specific arguments):__

####vote.threshold

if __vote.threshold__ was set to be a bit higher: 0.51, then gene2 is eliminated
because it was voted for in AssocObject2
 
```{r, echo=FALSE}

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 associations <- list(AssocObject,AssocObject2)
 names(associations) <- c("H3K4me1","H327ac")
 
 # Run voteAssociations
 voteAssociations(associations, 
                  cutoff.stat="pval",
                  cutoff.val=0.05,
                  vote.threshold=0.51)
                  
```

Thus __vote.threshold__ is a value between 0 and 1, and it designates the threshold needed for fraction of votes necessary to retain an association. As default 0.5: fraction of votes should be greater than or equal to 0.5 to retain association.

####cutoff.stat
Which statistics to filter:"qval" or "pval",...

####cutoff.val
a numeric cutoff that will be used to filter elements in the input list ( __cutoff.stat__ ).
If the input object lacks this column, every association in the object will be treated as a valid association prediction.

---

## 2c. Integrating different algorithms and data sources via metaAssociations()


---


__IN DETAIL__

__metaAssociations()__ combines association P-values and coefficients from different data sets 
using __Fisher's method__ and weigthed averaging respectively. It is useful to combine
datasets produced by different research groups while avoiding problems such as batch effects.

For example, it can be used to combine Roadmap and Blueprint __associateReg2Gene__ gene~enhancer single-model information obtained using across-cell  RNA-Seq signals and CHiP-Seq H3K27ac tracks.

Aggregating single-model information (gene-enhancer pairs)  by means of meta-analysis across different data-sources increases the statistical power, improves the precision and accuracy of estimates and altogether produces more robust and reproducible results (Kirkwood 1998)

After, combining P-values, q-values are calculated using the qvalue function.

### Meta-analysis - simplified pictorial representation:

```{r, fig.height = 10, fig.width = 10, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/Meta-Analysis_Simplified.png")

```


__metaAssociations() OUTPUT:__

is a GInteractions object with an updated statistics from the meta-analysis: meta-analyzed p-values,q-values, test statistics (coefs). As well as __n__ or number of input cell types used while running this meta-analysis.

The output is similar to the output of __associateReg2Gene()__ because it just combines __associateReg2Gene()__ results across different __associateReg2Gene()__ output results.

```{r, echo=FALSE}
# creating datasets

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 associations <- list(AssocObject,AssocObject2)
 names(associations) <- c("Roadmap","Blueprint")
 
 # Run metaA
 metaAssociations(associations)
 
```

Which was runned as: metaAssociations(associations)

__INPUT DATA DETAIL description (min arguments):__

####associations 
A list of GInteractions objects outputed from __associateReg2Gene()__ as shown:
```{r, echo=FALSE}
# creating datasets

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 associations <- list(AssocObject,AssocObject2)
 names(associations) <- c("Roadmap","Blueprint")
 
 # Run metaA
 associations

```

__INPUT DATA DETAIL description (metaAssociations() specific arguments):__
 
None

---

# 3. Benchmarking results and assessing performance

---

## 3.a Benchmarking results - benchmarkGI()

---

Associated gene-enhacer pairs (an output of associateReg2Gene()) can be easily
__benchmarked__ using the second set of linked genes and enhancers. For example, coordinates of predicted interacting regions in the genome, as resulted from
chromatin conformation capture and related methods (CHiA-PET, 4C, 5C, HiC, 
PC-HiC) can be used to benchmark results of __reg2gene gene-enhacer modelling__ procedure. 
Likewise, a benchmark dataset against which you can compare modelling results, can be experimentaly confirmed enhnacer~gene pairs (Visel et al. 2009), or eQTL-gene associations(GTEx Consortium).

Thus, __benchmarkGI()__ takes two GInteractions objects as an input, and the first 
object (__reg2Gene__) is benchmarked with respect to the second one (__benchData__). 


__IN DETAIL__


If anchor1 of the first GInteractions object (__reg2Gene__) overlaps either anchor1 or anchor2 of the second GInteractions object (_benchData__), then anchor2 of the first GInteractions necessarily needs to overlap the opposite pair in the benchmark dataset (2nd GInteractions object). In other words, criss-cross overlap of interacting regions is performed: if anchor1 from the benchmark dataset is overlapping anchor2 from the tested set, than anchor2 from the benchmark dataset needs to overlap anchor1 from the tested set, or vice-versa.

## Schematic representation of possible benchmarking procedure

```{r fig5, fig.height = 5, fig.width = 3, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/BenchSimpleE.png")

```


For example, 

anchor1 from the test set overlaps anchor1 from the benchmark set (and anchor2 overlaps anchor2).

Anchor 1 of test set: 

```{r, echo=FALSE}
tmp <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[2]
mcols(tmp) <- NULL
tmp
```

Overlaps anchor1 of the benchmark set: 
```{r, echo=FALSE}
tmp <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[5]
mcols(tmp) <- NULL
tmp
```

However, to be reported as benchmarked anchor1-anchor2 set (a tested gene-enhancer pair) an anchor2 needs to overlap anchor2 as well:
```{r}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[2]
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
   
   # removing confusing meta-data
   mcols(reg2Gene) <- NULL
   
benchmarkGI(reg2Gene,
            benchData,
            binary=TRUE) 
```

As shown above:

###__benchmarkGI() OUTPUT:__

is equal to the input GInteractions object (__reg2Gene__), BUT with added benchmark results metadata as a "Bench" column.


An opposite benchmarking example is when anchor1 of the test set  (__reg2Gene__) overlaps anchor2 of the benchmark set. Then anchor2 of the test set necessarily needs to overlap anchor1 of the benchmark set:
```{r, echo=FALSE}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[6]
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[6]
   
    # removing confusing meta-data
   mcols(reg2Gene) <- NULL 
   mcols(benchData) <- NULL
   
  print("test set:")
   reg2Gene
  
  print("benchmark set:")
   benchData
   
 print("after benchmarking results in:")
benchmarkGI(reg2Gene,
            benchData,
            binary=TRUE) 
```


Additionally, anchor2 can overlap anchor2 (anchor1 overlaps anchor1 in that case).

---


By default Bench column in the output object of the __benchmarkGI()__ reportes how many times interactions is observed in the benchmark dataset. 

For example, GInteractions pair

chr1 [100, 101] ---      chr1 [102, 103]

can be benchmarked 3 times using following benchmark dataset:

```{r, echo=FALSE}
tmp <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]
mcols(tmp) <- NULL
tmp

```
And results in:
```{r, echo=FALSE}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[7]
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]

   mcols(reg2Gene) <- NULL
   
    bench <- benchmarkGI(reg2Gene,
            benchData,
            binary=FALSE) 
   
    bench
    
```  
   
  
However, __benchmarkGI()__ can report as well whether gene~enhancer pair matches some pair in the benchmark dataset or not. 

Then set, argument 

####binary

to be TRUE.

```{r, echo=FALSE}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[7]
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]

   # removing confusing meta-data
   mcols(reg2Gene) <- NULL
   mcols(benchData) <- NULL
   
   reg2Gene
   benchData
   
    benchmarkGI(reg2Gene,
            benchData,
            binary=TRUE) 
```  

######IMPORTAT NOTE!!!

If anchor1&anchor2 both overlap only one anchor of the anchor pair in the benchmark they are not benchmarked.
 
However, one need to be careful when benchmarking anchors that overlap within the test set (eg enhancer overlaps gene region), because they will be benchmarked with 
__benchmarkGI()__.





__INPUT DATA DETAIL description (benchmarkGI() minimum arguments):__

####reg2Gene 
a GInteractions object to be benchmarked using

####benchData 
a second GInteractions object used as benchmark dataset. Or a list of GInteractions objects, as follows:

```{r}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
  

  benchDataList <- list(benchData,reg2Gene)
  names(benchDataList) <- c("benchData1","benchData2")


                benchmarkGI(reg2Gene,
                        benchDataList,
                        ignore.strand=TRUE,
                        binary=FALSE,
                        nCores = 1)   

```


__INPUT DATA DETAIL description (benchmarkGI() specific arguments):__
 
####nCores
An option for parallel processing using mclapply from parallel package.

####ignore.strand
is an argument that should be passed to findOverlaps. When set to TRUE, 
the strand information is ignored in the overlap analysis.

####binary
As mentioned before this is FALSE or TRUE, and defines whether function reports how many times tested gene~enhancer pair is present in the benchmark dataset; or whether at all this gene~enhancer pair matches some pair in the benchmark dataset or not



---


## 2b. Assessing model performance - confusionMatrix()


---


Performance of the modelling procedure can be easily assessed by calculating confusion matrix elements using __confusionMatrix__.

Thus, __confusionMatrix__ reports statistics based on the confusion matrix. 

__IN DETAIL__

There are four different elements of the confusion matrix: 

    TP = (number of) true positive: reg2gene entry that was reported to be associated (reported gene-enhancer statistics lower than a predefined threshold) and was benchmarked. 
    
    FP = (number of) false positive: reg2gene entry that was reported to be associated (reported gene-enhancer statistics lower than a predefined threshold) BUT was not overlapped with benchmark dataset 
    
    FN = (number of) false negative: reg2gene entry that was NOT reported to be associated (reported gene-enhancer statistics NOT lower than a predefined threshold) BUT is benchmarked 
    
    TN = (number of) true negative: reg2gene entry that was NOT reported to be associated (reported gene-enhancer statistics NOT lower than a predefined threshold) AND is NOT benchmarked. If no benchmark and no statistically significant data is entered, then 0 is reported.


From previous categories __confusionMatrix()__ calculates following matrices: 


$Sensitivity = TP/(TP+FN)$ 

$Specificity = TN/(TN+FP)$

$Accuracy = (TP+TN)/(TP+FN+FP+TN)$

$PPV = TP/(TP+FP)$ 

$NPV = TN/(TN+FN)$ 

$F1 = (2*TP)/((2*TP)+FP+FN)$


__INPUT DATA DETAIL description (confusionMatrix() min arguments):__

####reg2GeneBench
GInteractions object with added benchmark benchmarkGI() and OPTIONAL  filterPreBenchGI() metadata (however,prior this analysis, it is advised to reduce the number of true negatives by including only reg2gene entries that could be potentially benchmarked).To get that info run filterPreBenchGI and add filter column with metadata from this function to reg2GeneBench GInteractions object prior running benchmarkGI)


####thresholdID
Character (def:NULL), name which indicates a column where statistics of the modelling procedure is stored: for example: "pval". If not changed to the existing column name, then function will return ERROR. This column is filtered such that everything below predefined threshold is considered to be statistically significant association (set to be equal to 0), whereas everything above that threshold is 0". Details below.



```{r, echo=FALSE}
reg2GeneBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- reg2GeneBench$anchor1.Bench1Exp
Filter <- reg2GeneBench$anchor1.Filter1Exp
      mcols(reg2GeneBench) <- NULL

   reg2GeneBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
  reg2GeneBench$Bench <- Bench
  reg2GeneBench$Filter <- Filter
  
  reg2GeneBench

```

cm function runned as:

confusionMatrix(reg2GeneBench,
                thresholdID = "Pval",
                thresholdValue = 0.05,
                benchCol = "Bench",
                prefilterCol = "Filter",
                statistics = "ConfusionMatrix")


###__confusionMatrix() OUTPUT:__

```{r, echo=FALSE}
reg2GeneBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- reg2GeneBench$anchor1.Bench1Exp
Filter <- reg2GeneBench$anchor1.Filter1Exp
      mcols(reg2GeneBench) <- NULL

   reg2GeneBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
   reg2GeneBench$Bench <- Bench
   reg2GeneBench$Filter <- Filter

confusionMatrix(reg2GeneBench,
                thresholdID = "Pval",
                thresholdValue = 0.05,
                benchCol = "Bench",
                prefilterCol = "Filter",
                statistics = "ConfusionMatrix")
```

Or only PPV if __statistics = "PPV"__  the output is:

```{r, echo=FALSE}
reg2GeneBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- reg2GeneBench$anchor1.Bench1Exp
Filter <- reg2GeneBench$anchor1.Filter1Exp
      mcols(reg2GeneBench) <- NULL

    reg2GeneBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
    reg2GeneBench$Bench <- Bench
    reg2GeneBench$Filter <- Filter

confusionMatrix(reg2GeneBench,
                thresholdID = "Pval",
                thresholdValue = 0.05,
                benchCol = "Bench",
                prefilterCol = "Filter",
                statistics = "PPV")
```


__INPUT DATA DETAIL description (confusionMatrix() specific arguments):__

####benchCol	
a column name where results of benchmarking procedure are stored.
Default: Bench. A vector of 0's and 1's is expected to be stored in __benchCol__ column.
Take a look at an example below.


####thresholdValue

Since __associatereg2Gene()__ reports all input gene-enhancer associations together with the corresponding test statistics, a threshold for this test statistics needs to be set as __thresholdValue__ in __confusionMatrix()__. 
Every gene-enhancer pair with test statistics below __thresholdValue__ will be considered to be statistically significant pair - POSITIVE. Otherwise, it is consider to be NEGATIVE.
Take a look at an example above.



__INPUT DATA DETAIL description (confusionMatrix() minimum arguments):__

####reg2GeneBench

GInteractions object with added benchmark benchmarkGI metadata. 

However,prior this analysis, it is advised to reduce the number of true negatives by including only reg2gene entries that could be potentially benchmarked.To get
these info run __filterPreBenchGI()__ and add filter column with metadata from __filterPreBenchGI()__

####statistics
This function output integer vector or a list. If "ConfusionMatrix" is requested then the output is list with following elements:__TP__, __FP__, __TN__, __FN__, __Specificity__, __Accuracy__, __PPV__, __NPV__,__F1__. 
Otherwise only __PPV__ is reported.



---


## 2c. Reducing the number of true negatives - filterPreBenchGI()

---

By identifying only gene and enhancer regions (anchor1 and anchor2 from the test set) that could be potentially benchmarked __filterPreBenchGI()__ reduces the number of true negatives in __confusionMatrix()__ statistics. 


__IN DETAIL__

It eliminates all regulatory region-TSS pairs [anchor1 and anchor2 from reg2Gene] that do not overlap with any benchmark anchor1 or anchor2 location. In other words, it selects reg2Gene regions only when both regulatory region and TSS  have overlapping regions somewhere in the benchmarking set; across all benchmark anchor pairs, and not necessarily overlapping regions of the same benchmark pair. 

This is useful to improve the __confusionMatrix()__ statistics reported by confusionMatrix by eliminating the high number of true negatives. __TN__ are very abundant in the reg2gene dataset since benchmark dataset usually covers much smaller (in number as well) regions of the genome (method limitations)


```{r, echo=FALSE}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
   
   # removing confusing meta-data
   mcols(reg2Gene) <- mcols(benchData) <- NULL
   
filterPreBenchGI(reg2Gene,
            benchData,
            binary=TRUE) 
```


As shown above:

###__filterPreBenchGI() OUTPUT:__

is equal to the input GInteractions object (__reg2Gene__), BUT with added benchmark results metadata as a "Filter" column. It contains only 0's and 1's (can be potentially benchmarked). This column is further used to improve results of __confusionMatrix()__ statistics.

--

If,  anchor1&anchor2  from the tested set both overlap only one region in benchmark dataset they will be filtered OUT...
 
```{r, echo=FALSE}

require(GenomicRanges)
require(InteractionSet)

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
  
filterPreBenchGI <- filterPreBenchGI(reg2Gene[1],benchData[1]) 
# removing confusing meta-data
Filter <- filterPreBenchGI$Filter
mcols(filterPreBenchGI) <- NULL
filterPreBenchGI$Filter <- Filter

``` 
Using following combinations of anchor1-anchor2 test vs anchor1-anchor2 benchmark dataset: 

```{r, echo=FALSE}
test <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[1]
mcols(test) <- NULL
test
bench <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[1]
mcols(bench) <- NULL
bench

```
 
__INPUT DATA DETAIL description (filterPreBenchGI () minimum arguments):__
 

####reg2Gene 
As in benchmarkGI(), a GInteractions object to be benchmarked using

####benchData 
As in benchmarkGI() a second GInteractions object used as benchmark dataset. Or a list of GInteractions objects, as follows: 

```{r}

   reg2Gene <- GInteractions(GRReg1_toy,GRReg1_toy$reg)
   benchData <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
  

  benchDataList <- list(benchData,reg2Gene)
  names(benchDataList) <- c("filterData1","filterData2")


                filterPreBenchGI(reg2Gene,
                        benchDataList,
                        ignore.strand=TRUE,
                        binary=FALSE,
                        nCores = 1)   

``` 
 
 
__INPUT DATA DETAIL description (filterPreBenchGI () additional arguments):__ 

####nCores

####ignore.strand

For description take a look at benchmarkGI() additional arguments


---


## Short background of the problem

### Enhancers
__Enhancers__ represent distal regulatory regions in the genome that can be located up to 1Mb from the transcription start sites of genes, increase gene expression regardless of their position, orientation and distance to the promoter.

### Enhancer-like chromatin marks
Different enhancer-like chromatin marks have been previously used to map these
regulatory regions and assess their activity: level of histone modifications
(especially __H3K4me1__ and __H3K27ac__), nucleosome depletion, __open chromatin accessibility__, __DNA methylation__, nucleotide conservation, etc. 
(Mathelier et al., 2015).  To improve reproducibility of mapping efforts, different chromatin marks were integrated in chromatin features (multiple modifications and more complex elements linked together, Stricker et al. 2017), combined with an unsupervised machine-learning approaches and higher number of cell types included in the mapping analysis (for example Ernst and Kellis 2012 used ChromHMM Core 15-state model and reported more than 900,000 potential enhancer regions across 127 epigenomes from the Roadmap Epigenomics Project (Kundaje et al. 2015).

###  Mapping potential gene targets of an enhancer regions

1) Mapping of regulatory regions and their targeted genes can be done computationally by correlating gene expression with levels of enhancer-
associated chromatin features. Ernst et al. 2011 correlated gene expression with different histone modification marks, including enhancer associated marks 
H3K27ac and H3K4me1 (ENCODE Project Consortium 2012), Sheffield et al. 2013 correlated DNase I Hypersensitivity and gene expression, whereas Varley et al. 2013 was focused on DNA methylation. This package enables easy integration of all these datasets.

1) A long-range interactions can be mediated by chromatin looping - a mechanism by which enhancers and promoters are brought together in the 3D space of a nucleus, which, at least partially, enables precise regulation of gene expression (Gorkin et al. 2014, Rennie et al. 2017). Thus information about the 3D genome architecture, generated by chromosome conformation capture and related techniques, is can be used as a proxy of enhancer-mediated regulation of gene expression or in these case __to benchmark results__ of reg2gene modelling approach (Dekker  et al. 2002, Dosie et al. 2006, Simonis et al. 2006, Fullwood et al. 2009, Lieberman-Aiden et al. 2009).

---

## Literature


Akalin, Altuna, et al. "Genomation: a toolkit to summarize, annotate and visualize genomic intervals." Bioinformatics 31.7 (2014): 1127-1129.

Bolstad, Benjamin Milo. "preprocessCore: A collection of pre-processing functions." R package version 1.0 (2013).

Dabney, Alan, John D. Storey, and G. R. Warnes. "qvalue: Q-value estimation for false discovery rate control." R package version 1.0 (2010). 

Dekker, Job, et al. "Capturing chromosome conformation." science 295.5558 (2002): 1306-1311.

Dostie, Jose, et al. "Chromosome Conformation Capture Carbon Copy (5C): a massively parallel solution for mapping interactions between genomic elements." Genome research 16.10 (2006): 1299-1309. 

ENCODE Project Consortium. "An integrated encyclopedia of DNA elements in the human genome." Nature 489.7414 (2012): 57-74.

Ernst, Jason, et al. "Mapping and analysis of chromatin state dynamics in nine human cell types." Nature 473.7345 (2011): 43-49.

Ernst, Jason, and Manolis Kellis. "ChromHMM: automating chromatin-state discovery and characterization." Nature methods 9.3 (2012): 215-216. 

Fullwood, Melissa J., et al. "An oestrogen-receptor--bound human chromatin interactome." Nature 462.7269 (2009): 58-64.

Gorkin, David U., Danny Leung, and Bing Ren. "The 3D genome in transcriptional regulation and pluripotency." Cell stem cell 14.6 (2014): 762-775.

Friedman, Jerome, Trevor Hastie, and Rob Tibshirani. "glmnet: Lasso and elastic-net regularized generalized linear models." R package version 1.4 (2009).

Kundaje, Anshul, et al. "Integrative analysis of 111 reference human epigenomes." Nature 518.7539 (2015): 317-330.

Lieberman-Aiden, Erez, et al. "Comprehensive mapping of long-range interactions reveals folding principles of the human genome." science 326.5950 (2009): 289-293.

Lonsdale, John, et al. "The genotype-tissue expression (GTEx) project." Nature genetics 45.6 (2013): 580-585.

Love, Michael I., Wolfgang Huber, and Simon Anders. "Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2." Genome biology 15.12 (2014): 550.

Mathelier, Anthony, Wenqiang Shi, and Wyeth W. Wasserman. "Identification of altered cis-regulatory elements in human disease." Trends in Genetics 31.2 (2015): 67-76.

Sheffield, Nathan C., et al. "Patterns of regulatory activity across diverse human cell types predict tissue identity, transcription factor binding, and long-range interactions." Genome research 23.5 (2013): 777-788.

Simonis, Marieke, et al. "Nuclear organization of active and inactive chromatin domains uncovered by chromosome conformation captureon-chip (4C)." Nature genetics 38.11 (2006): 1348-1354.

Stricker, Stefan H., Anna Kferle, and Stephan Beck. "From profiles to function in epigenomics." Nature Reviews Genetics (2016).

Varley, Katherine E., et al. "Dynamic DNA methylation across diverse human cell lines and tissues." Genome research 23.3 (2013): 555-567.

Visel, Axel, et al. "VISTA Enhancer Browsera database of tissue-specific human enhancers." Nucleic acids research 35.suppl 1 (2007): D88-D92.

Wright, Marvin N., and Andreas Ziegler. "ranger: A fast implementation of random forests for high dimensional data in C++ and R." arXiv preprint arXiv:1508.04409 (2015).









