---
title: "reg2gene"
author: "Inga Patarcic"
date: "`r Sys.Date()`"
output:  
  html_document:
        toc: true
        toc_float: true
        number_sections: true
        toc_depth: 3
vignette: >
  %\VignetteIndexEntry{reg2gene}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r global_options, include=FALSE}

library(knitr)
library(reg2gene)
library(InteractionSet)
library(GenomicRanges)
library(rmarkdown)

opts_chunk$set(warning = FALSE,
               message= FALSE,
               fig.align='center',
               fig.path='Figures', 
               dev='png',
               fig.show='hold', 
               cache=FALSE)


```


# Introduction


reg2gene R package was build to perform two main categories of tasks:
  
__1. to build **gene expression ~ enhancer activity** models__ -
    
to associate target genes to regulatory elements genome-wide.
    
__2. to annotate user provided genomic regions to genes__ - 
    


__TASK 1: Building models & predicting target genes__
set of reg2gene functions allows users to perform: 

* 1. DATA INTEGRATION - e.g. to extract information stored in bigWig files
(across  different cell types) to:
     + a. quantify (enhancer) activity (regulatory potential) for genomic regions 
of interest (enhancer regions), and
     + b. quantify gene expression for genes of interest, and/or
     + c. to combine these informations into one object used further for modelling

*  2. DATA MODELLING (including performance assessment) - model of 
gene expression - enhancer activity using different algorithms, and combine
different models with meta-analysis and voting procedure.
Additionally, one can benchmark results and obtain confusion matrix.

* 3. DATA VISUALIZATION - Reported regulatory regions - genes associations can
be visualized as loops in the context of the genome. 

## Schematic representation of quantification and data integration:

```{r fig2, fig.height = 5, fig.width = 3, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/QuantificationDataIntegrationSimplified.png")

knitr::include_graphics("/data/akalin/Projects/AAkalin_reg2gene/reg2gene/vignettes/Figures/QuantificationDataIntegrationSimplified.png")
```

__TASK 2: Annotate user provided genomic regions to the genes__

One can annotate regions of interest (ChIP-Seq peaks or similarily defined
genomic regions) to the genes they are associated with, based on the result
of modelling enhancer-gene associations. 

Optionally, one can as well associate genes with diseases reported in the
disease-gene databases.


-----------------------------------------------------------------------------

This vignette describes necessary input data for __reg2gene__ package and 
demonstrates following functionalities :


*  1) How to quantify gene expression?

*  2) How to quantify enhancer activity?

*  3) How to prepare data prior modelling procedure?

*  4) How to run models of gene expression ~ enhancer activity?

*  5) How to benchmark reported enhancer-gene associations?

*  6) How to assess modelling performance?

*  7) How to visualize reported enhancer-gene associations?

*  8) How to annotate user provided genomic regions to the genes?



-----------------------------------------------------------------------------


# Building models with reg2gene

## How to quantify gene expression?

__FUNCTION OF CHOICE: bwToGeneExp()__

__BACKGROUND__

Before running a modelling analysis, for genes and enhancers of interest, 
gene expression and enhancer activity need to be quatified (and normalized)
-> __Data integration__ step of the analysis.


__IN DETAIL:__

In short, this function firstly quantifies __exon expressions__ over pre-defined 
exon regions using signal from RNA-Seq tracks (bigwig files), then it sums over 
all exons of a gene of interest to obtain levels of __gene expression__.
With this function, gene expression levels can be quantified over a set of 
samples, cell types or conditions (list of .bigWig files).


__DESCRIPTION__

For a gene of interest and across all input samples (.bw files) individaully,the 
expression is firstly calculated for all exon regions definded in the input 
GRanges object (exons argument, details below). 
For quantificatons of enhancer activity over this exon regions, 
a ScoreMatrixBin() from the genomation package is used. 


This is followed by per gene expression quantification as follows:

___

$Gene Expression=\sum_{i=1}^n (Exon Expression_n * ExonLength_n)/(GeneLength)$


$GeneLength=\sum_{i=1}^n ExonLength_n$

___
 
e.g. mean exon expression scores are multiplied by the exon length,summed 
together and divided by the gene length(a sum of all exon lengths for that gene)
After quantifying gene expression, a normalization step ("quantile" or "ratio")
can be runned.

NOTES:
This function might be extended to work with BAM files in the future, 
however now it works only with relevant .bigWig files
RNA-Seq .bw files can originate from stranded,unstranded or mixed libraries.

__bwToGeneExp() OUTPUT:__

When quantification using bwToGeneExp() is performed using toy examples 
of input GRanges objects (regTSS_toy) and a list of bigWig files
(regActivityInputExample) a following result is obtained:

```{r}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3,5,5,5))
                                        
                                        
 bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw))


```

For each gene, information is quantified first across exons and then summed 
per gene to quantify gene expression levels.

In the following toy example there are 3 genes: TEST_Reg1, TEST_Reg3 and
TEST_Reg5 with different number of exons:

TEST_Reg1 has 2 exons,

TEST_Reg3 has 1 exons,

TEST_Reg3 has 5 exons,


Notice that output GRanges object now has 3 genomic ranges reported which 
correspond to the toy genes analyzed: TEST_Reg1,TEST_Reg3 and TEST_Reg5.
For these genes TSS is location is reported in the genomic ranges object.

Additionally, if exons input is of GInteractions class object, 
the same output GRanges object is obtained: 

```{r,echo=FALSE}

require(InteractionSet)

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
 test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
 
 regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                       IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                             c(rep("+",3),rep("-",3)))
  regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
  regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",c(1,1,3,5,5,5))
 
 # if exons input is of GInteractions class object, the same output is obtained
 
 exons= GInteractions(regTSS_toy,regTSS_toy$reg)
    exons$name=regTSS_toy$name
    exons$name2=regTSS_toy$name2
    
     exons
   
     print("Which results in:")
     
    bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw))

```


## How to quantify enhancer activity?

__FUNCTION OF CHOICE: regActivity()__

__BACKGROUND__

Before running a modelling analysis, for genes and enhancers of interest, 
gene expression and enhancer activity need to be quatified (and normalized)
-> __Data integration__ step of the analysis.


__IN DETAIL__

Enhancer activity can be quantified based on the bigWig tracks of ChIP-Seq
signals for histone modifications (such as H3K27ac and H3K4me1, 
but for any other histone modification as well), of DNase-seq signals and of 
bisulfite-sequencing results for DNA methylation for any pre-defined 
GRanges object which contains info about enhancer regions in the genome.

To quantify enhancer activity __regActivity()__ is used, and this funcion
performs across a set of samples.

__DESCRIPTION__

For a regulatory regions of interest and across all input samples (.bw files)
individaully the activity is calculated using ScoreMatrixBin() from the 
genomation package. Regulatory activity is measured by averaging logFC for 
histone modification ChIP-seq profiles, or DNAse signal, or DNA methylation
per base. A before, relevant bigWig files are required to calculate activity,but 
function might be extended to work with BAM files
in the future. 

An output of a function is a GRanges object where its meta-columns 
correspond to the calculated activity levels per input sample. Column names 
correspond to provided sample ids or names.

__regActivity() OUTPUT:__

```{r}
test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",4),rep("chr2",2)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                                            c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3:6)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                        c(1,1,3:length(regTSS_toy)))
regActivity(regTSS_toy,c(test.bw,test2.bw))   

```



## How to prepare data prior modelling procedure?

__FUNCTION OF CHOICE: regActivityAroundTSS()__

__BACKGROUND__
After quantification has been done, 
quantified enhancer activities and gene expressions need to be stored in one
GRanges object, in the following manner: 
for each gene include all enhancers within a certain range from the 
TSS (transcriptional start site) of a gene (by default it is +/-1Mb).

This is important since many enhancers do not necessarily regulate the 
closest gene (Mifsud et al. 2015, Schoenfelder et al 2015, 
Javierre et al. 2016), but they bypass nearby genes while forming long-range
interactions with targeted promoters (Tolhuis et al. 2002, Lettice et al. 2003)
and vice-versa, genes are commonly regulated by more than one enhancer region 
(Tolhuis et al. 2002).



__IN DETAIL__

1) Identify enhancers located within certain window from TSS
2) Create GRanges list where, per gene, gene expression & enhancer activity
for nearby enhancers will be stored.

__DESCRIPTION__

An output of __regActivityAroundTSS()__ is a GRangesList object that contains 
per gene GRanges (names for the GRangesList are unique gene ids/names).
Each GRanges stores location of the corresponding TSS and regulatory regions 
identified around that gene. 
Metadata for each GRanges object in the GRangesList represents regulatory 
activity and gene expression quantified across a number of samples (.bw files)
that have matched IDs in RNA-Seq and CHiP-Seq,DNase-Seq or bisulfite sequencing 
experiment. 

Thus, GRanges objects have the following metadata columns:
     
     1. featureType: either "gene" or "regulatory" 
     2. name: name/id for gene and enhancers. Gene name could 
     be id from a database enhancer name should be in the format as follows 
     "chr:start-end" 
     3. name2: a secondary name for the feature, such as gene symbol "PAX6" etc.
     not necessary for enhancers could be NA 
     4. other columns: numeric values for gene expression or regulatory actvity.
     Column names represent sample names/ids


Importantly, only enhancers located within predefined (+/-) upstream/downstream 
regions of TSS are identified, extracted and reported in output 
(together with info about gene expression). 


!!! Sample id's (corresponding to the cell types or conditions) are included in 
output object only if both, 1) gene expression 
values and 2) quantified regulatory activity are available in TSS and
regActivity objects. Non-overlapping cell types are excluded.


__regActivityAroundTSS() OUTPUT:__

```{r}

regTSS_toy <- GRReg1_toy
  regTSS_toy$bw1 <- rep(1,length(GRReg1_toy))
  regTSS_toy$bw2 <- rep(2,length(GRReg1_toy))
  regTSS_toy$bw3 <- rep(3,length(GRReg1_toy))
regReg_toy <- GRReg2_toy
   regReg_toy$bw1 <- rep(3,length(regReg_toy))
   regReg_toy$bw2 <- rep(4,length(regReg_toy))

regActivityAroundTSS(regReg_toy,regTSS_toy,upstream=1,downstream=1)


```

NOTE: In the previous example there are 3 genes: TEST_Reg1, TEST_Reg2, 
TEST_Reg3 so GRanges in GRangesList object are named accordingly.


## How to run models of gene expression ~ enhancer activity?

__FUNCTION OF CHOICE:associateReg2Gene()__

__BACKGROUND__

To link enhancer activity and gene expression __reg2gene__ functions utilize 
__correlate__ and/or use other statistical approaches, __elastic net__ 
and __random forests__,  to model __ gene expression ~ enhancer activity __ 
across different cell types. 
This approach is based on the observation that enhancers show very high tissue 
specificity and the level of their activity correlates with gene expression 
(Visel et al. 2009., Ernst et al. 2011).

__ANALYSIS SCOPE__

All analyses can be done easily for different types of enhancer-related
chromatin marks ( __H3K4me1__, __H3K27ac__, __DNA methylation__, __DHS__, etc.) 
and for different sources of data (Roadmap, Blueprint or in-house datasets), as
well as different algorithms can be used: dcor, elastic net, random forest,
spearman and pearson correlation coefficient.

Additionaly, single-model information (gene-enhancer pairs) can be aggregated 
by means of __meta-analysis__ across different data-sources or by 
__majority voting__ decisions across both different modelling procedures/
data-types/data-sources. This analysis is possible only when more that one 
modelling procedure has been performed.



__IN DETAIL__

The function implements five methods to associate regulatory activity to genes:

    correlation (Pearson and/or Spearman), 
    
    distance correlation ("dcor"), 
    
    elasticnet and
    
    random forests. 
    
__Correlation__ is implemented to capture linear individual 
enhancer~gene relationships. Likewise, simple linear regression on scaled data 
is equivalent to Pearson correlation.


__Distance correlation__ is a metric for statistical 
dependence between two variables. It can capture non-linear relationships
different from correlation.

__Elasticnet__ and __randomForests__ are methods that can capture additivity
between regulatory activities and their relationship to gene expression. 
For details about these methods take a look at:


For all the methods, __P-values__ are estimated by __shuffling__ the gene 
expression vector __B times__ and getting a null distribution for the estimated 
statistic, and comparing the original statistic to the null distribution.
Estimated statistics are __correlation coefficients__ for correlation and 
distance correlation methods, regression coefficients for elasticnet and
__gini importance__ scores for random forests. P-values from resampling 
statistics are estimated using Gamma distribution, e.g. gamma distribution 
based P-values from the null distribution are obtained from resampling 
(gamma distribution is fit to the null distribution and p-values are calculated
based on that fitted distribution).

An output of this function is  GInteraction object containing every 
potential association and between a regulatory region and TSS, and the 
estimated association statistic: its P-values and Q-values.


For the __output of regActivityAroundTSS()__ object

```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation
 
 require(GenomicRanges)
 require(doMC)
 require(glmnet)
 require(foreach)
 require(stringr)
 require(qvalue)
 
 ####################################
 # create example
 
 x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
      2.599857,4.216959,2.589133,1.848172,3.039659)
 y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
      5.048476,2.884551,2.780067,4.053136)
 corrM <- rbind(x,y)
 
 # define Granges object
  gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))
    
    GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

        colnames(GeneInfo) <- c("featureType","name","name2")

       mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))
 
 
       gr0
       
    
```

__Run associateReg2Gene()__ as follows:

```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation
 
 require(GenomicRanges)
 require(doMC)
 require(glmnet)
 require(foreach)
 require(stringr)
 require(qvalue)
 
 ####################################
 # create example
 
 x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
      2.599857,4.216959,2.589133,1.848172,3.039659)
 y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
      5.048476,2.884551,2.780067,4.053136)
 corrM <- rbind(x,y)
 
 # define Granges object
  gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))
    
    GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

        colnames(GeneInfo) <- c("featureType","name","name2")

       mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))
 
    print("associateReg2Gene(gr0,cores = 1,B=100)")
    associateReg2Gene(gr0,cores = 1,B=100)     
   
```


This example was created to have correlation between gene expression
and enhancer activity equal to 0.8. This estimated association statistic is 
reported as __coefs__ and is recalculated as 0.8. Associated P-values are
calculated in and reported as __pval__.
Corresponding __qval__ is calculated. However, q-values are set
to be NA since, this toy example contains only one gene~enhancer pair, 
thus one p-value is calculated but q-values cannot be calculated based on only 
one p-value.



Importantly, this function does not report statistically significant 
gene-enhancer associations, whereas it reports all input gene-enhancer 
associations and corresponding test statistics. It is up to researcher to decide
which gene-enhancer associations they consider to be statistically significant
pairs.


__MODELLING ADDITIONS: meta-analysis & voting__

In cases when more that one modelling procedure has been performed, one can
try to combine these results. This package can perform meta-analysis and 
voting procedure.


__voting__

__FUNCTION OF CHOICE:voteInteractions()__


__BACKGROUND__

__When can you perform voting?__

You can perform voting analysis to combine models that differ in 
algorithm, or method, or cohort (just as meta-analysis) used when modelling.

For example,
for Roadmap H3K4me1 dataset 5 different modelling algorithms can be used:
dcor, spearman, pearson, elastic net & random forests, and results of all these
can be combined by voting. 

The results of this voting procedure is a list of gene~enhancer associations 
which have been confirmed by at least two or more algorithms.

The same thing can be done for combining gene~enhancer associations 
which have been confirmed by at least two or more methods/experimantal type,
e.g. voting by method I used to combine H3K4me1, H3K27ac, DNAme and DNaze 
modelling results based on for example Roadmap&dcor models.


__IN DETAIL__

Multiple associations output by different methods and data sets can be 
combined this way, and only the associations that have support in
__vote.threshold__ fraction of the datasets will be retained. 

__voteInteractions()__ selects POSITIVES 
(statistically associated gene~enhancer pairs) 
for each result of __associateReg2Gene()__ analysis that wants
to be combined by  __majority voting__ 
(for example results of __H3K4me1__ and __H3K27ac__ __associateReg2Gene()__
analysis). 

Assessing statistically associated gene-enhancer pairs has been done by
filtering the statistics (__cutoff.stat__) of the elements of the input list
(gene-enhancer pairs) based on the defined cutoff value (__cutoff.val__). 

For example, retain only gene-enhancer pairs that are supported by 
modelling __reg2gene__ analysis using both __H3K4me1__ and __H3K27ac__ to 
quantify enhancer activity. Or, retain only gene-enhancer pairs that are 
supported by modelling __reg2gene__ analysis using 
__pearson__, __spearman__ and __elasticnet__ algorithms.


Schematic representation of majority voting:

```{r fig3, fig.height = 5, fig.width = 5, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/master/vignettes/Figures/VOTING.png")

knitr::include_graphics("/data/akalin/Projects/AAkalin_reg2gene/reg2gene/vignettes/Figures/VOTING.png")

```


__voteInteractions() OUTPUT:__

is GInteractions object with gene~enhancer interactions voted above predefined
threshold (reported as __votes__ column).
```{r, echo=FALSE}

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 interactions <- list(AssocObject,AssocObject2)
 names(interactions) <- c("H3K4me1","H327ac")
 
 # Run voteInteractions
 voteInteractions(interactions, 
                  cutoff.stat="pval",
                  cutoff.val=0.05,
                  vote.threshold=0.5)
                  
```

By defult then following command was runned:
voteInteractions(interactions, cutoff.stat = "pval", cutoff.val = 0.05,
vote.threshold = 0.5) 
And this example was based on the following input data:



-----------------------------------------------------

Additionally, one can perform meta-analysis:


__FUNCTION OF CHOICE:metaInteractions()__

__BACKGROUND__

__When can you perform meta-analysis?__

If you have information coming from different cohorts, or produced by different 
organizations/data centers,and thus there is no overlap between samples, 
one can run meta-analysis to combine p-values from individual models 
[for given combination of enhancer region-gene expression]. Meta-analysis should
improve reprodicibility of modelling results.

For example,
I runned meta-analysis in the following case:
1) I selected enhancer regions and genes I want to model
2) For selected enhancer regions I quantified and normalized enhancer activity 
based on H3K4me1 .bigwig tracks for different cell types. I did that 
for .bigwig tracks that are reported as a result of Roadmap consortium.

However, there are other sources of publically available per cell type
H3K4me1 .bigwig files (take a look at the IHEC web site). Thus,
I repeated the same quantification procedure for other available individual 
experiments/consortiums .bigwig files: Blueprint, CEEHRC: CEMT & McGill.

Altogether, for every tested enhancer~gene associations I 
runned four different models -> one for each data-source. Since, there is no
overlap between data coming from different sources I can meta-analyze results of 
each gene-enhancer model.

NOTE!
When you meta-analyze, you can do that only for the corresponding combination of
experimental type/method(H3K4me1) and algorithm (spearman). You do not 
meta-analyze results of different modelling procedures (spearman+pearson, or 
H3H27ac and DNAme).

__IN DETAIL__

__metaInteractions()__ combines association P-values and coefficients from 
different data sets using __Fisher's method__ and weigthed averaging 
respectively. It is useful to combine
datasets produced by different research groups while avoiding problems 
such as batch effects.

For example, it can be used to combine Roadmap and Blueprint 
__associateReg2Gene__ gene~enhancer single-model information obtained using
across-cell  RNA-Seq signals and CHiP-Seq H3K27ac tracks.

Aggregating single-model information (gene-enhancer pairs)  by means of 
meta-analysis across different data-sources increases the statistical power, 
improves the precision and accuracy of estimates and altogether produces more 
robust and reproducible results (Kirkwood 1998)

After, combining P-values, q-values are calculated using the qvalue function.

Meta-analysis - simplified pictorial representation:

```{r, fig.height = 10, fig.width = 10, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/Meta-Analysis_Simplified.png")


knitr::include_graphics("/data/akalin/Projects/AAkalin_reg2gene/reg2gene/vignettes/Figures/Meta-Analysis_Simplified.png")
```


__metaInteractions() OUTPUT:__

is a GInteractions object with an updated statistics from the meta-analysis:
meta-analyzed p-values,q-values, test statistics (coefs). As well as __n__ or 
number of input cell types used while running this meta-analysis.

The output is similar to the output of __associateReg2Gene()__ because 
it just combines __associateReg2Gene()__ results across different
__associateReg2Gene()__ output results.

```{r, echo=FALSE}
# creating datasets

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
   x <- 1:5
   y <- 2:6
   z <- 10:14
   a <- rep(0,length(x))
   
   
   GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
               ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
               colnames(GeneInfo) <- c("featureType","name","name2")
 
 mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
 mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))
 
 # create associateReg2Gene output objects, GInteractions will all 
 # output results
 
 AssocObject <- reg2gene::associateReg2Gene(gr)
 AssocObject2 <- reg2gene::associateReg2Gene(gr2)
 
 # input for meta-analysis is list of such objects
 
 interactions <- list(AssocObject,AssocObject2)
 names(interactions) <- c("Roadmap","Blueprint")
 
 # Run metaA
 metaInteractions(interactions)
 
```

Which was runned as: metaInteractions(interactions)


## How to benchmark reported enhancer-gene associations?

__FUNCTION OF CHOICE:benchmarkInteractions()__

__BACKGROUND__

Associated gene-enhacer pairs (an output of associateReg2Gene()) can be easily
__benchmarked__ using the second set of linked genes and enhancers. 
For example, coordinates of predicted interacting regions in the genome, as
resulted from
chromatin conformation capture and related methods (CHiA-PET, 4C, 5C, HiC, 
PC-HiC) can be used to benchmark results of __reg2gene gene-enhacer modelling__
procedure. 
It is so since, information about the 3D genome architecture, can be used as
a proxy of enhancer-mediated regulation of gene expression 
(Dekker  et al. 2002, Dosie et al. 2006, Simonis et al. 2006,
Fullwood et al. 2009, Lieberman-Aiden et al. 2009), and thus can represent a
good benchmark dataset __to benchmark results__ of reg2gene modelling approach.
Likewise, a benchmark dataset against which you can compare modelling results, 
can be experimentaly confirmed enhnacer~gene pairs (Visel et al. 2009), or 
eQTL-gene associations(GTEx Consortium).



__IN DETAIL__

__benchmarkInteractions()__ takes two GInteractions objects as an input, 
and the first object (__interactions__) is benchmarked with respect to the second
one (__benchInteractions__). 


If anchor1 of the first GInteractions object (__interactions__) overlaps either 
anchor1 or anchor2 of the second GInteractions object (_benchInteractions__), 
then anchor2 of the first GInteractions necessarily needs to overlap the 
opposite pair in the benchmark dataset (2nd GInteractions object). In other 
words, criss-cross overlap of interacting regions is performed: if anchor1 
from the benchmark dataset is overlapping anchor2 from the tested set, than
anchor2 from the benchmark dataset needs to overlap anchor1 from the tested set,
or vice-versa.



Schematic representation of possible benchmarking procedure

```{r fig5, fig.height = 5, fig.width = 3, fig.align = "center"}
#knitr::include_graphics("https://github.com/BIMSBbioinfo/reg2gene/blob/master/vignettes/Figures/BenchSimpleE.png")

knitr::include_graphics("/data/akalin/Projects/AAkalin_reg2gene/reg2gene/vignettes/Figures/BenchSimpleE.png")

```

Running benchmark:

```{r}

   interactions <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[2]
   benchInteractions <- GInteractions(GRReg2_toy,GRReg2_toy$reg)
   
   # removing confusing meta-data
   mcols(interactions) <- NULL
   
benchmarkInteractions(interactions,
            benchInteractions,
            binary=TRUE) 
```

In the example above, 

anchor1 from the test set overlaps anchor1 from the benchmark set
(and anchor2 overlaps anchor2).

Anchor 1 of test set: 

```{r, echo=FALSE}
tmp <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[2]
mcols(tmp) <- NULL
tmp
```

Overlaps anchor1 of the benchmark set: 
```{r, echo=FALSE}
tmp <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[5]
mcols(tmp) <- NULL
tmp
```

However, to be reported as benchmarked anchor1-anchor2 set
(a tested gene-enhancer pair) an anchor2 needs to overlap anchor2 as well:


__benchmarkInteractions() OUTPUT:__

is equal to the input GInteractions object (__interactions__), 
BUT with added benchmark results metadata as a "Bench" column.



## How to assess modelling performance?

__FUNCTION OF CHOICE:confusionMatrix()__

__BACKGROUND__

__confusion matrix__ can be calculated to assess performance of 
the modelling procedure based on the external benchmark dataset and the
resuls of benchmarkInteractions(). 

__IN DETAIL__

There are four different elements of the confusion matrix: 

    TP = (number of) true positive: reg2gene entry that was reported to be 
    associated (reported gene-enhancer statistics lower than a predefined
    threshold) and was benchmarked. 
    
    FP = (number of) false positive: reg2gene entry that was reported to 
    be associated (reported gene-enhancer statistics lower than a predefined
    threshold) BUT was not overlapped with benchmark dataset 
    
    FN = (number of) false negative: reg2gene entry that was NOT reported to
    be associated (reported gene-enhancer statistics NOT lower than a predefined 
    threshold) BUT is benchmarked 
    
    TN = (number of) true negative: reg2gene entry that was NOT reported to be 
    associated (reported gene-enhancer statistics NOT lower than a predefined 
    threshold) AND is NOT benchmarked. If no benchmark and no statistically
    significant data is entered, then 0 is reported.


From previous categories __confusionMatrix()__ calculates following matrices: 


$Sensitivity = TP/(TP+FN)$ 

$Specificity = TN/(TN+FP)$

$Accuracy = (TP+TN)/(TP+FN+FP+TN)$

$PPV = TP/(TP+FP)$ 

$NPV = TN/(TN+FN)$ 

$F1 = (2*TP)/((2*TP)+FP+FN)$

Usaully, benchmarking needs to be performed since confusion matrix is based on
the result of benchmarking...

However, I created this example manually:

```{r, echo=FALSE}
interactionsBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- interactionsBench$anchor1.Bench1Exp
Filter <- interactionsBench$anchor1.Filter1Exp
      mcols(interactionsBench) <- NULL

   interactionsBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
   interactionsBench$Bench <- Bench
   interactionsBench$Filter <- Filter
  
  interactionsBench

```

confusionMatrix should be runned as follows:

```{r, echo=FALSE}
interactionsBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- interactionsBench$anchor1.Bench1Exp
Filter <- interactionsBench$anchor1.Filter1Exp
      mcols(interactionsBench) <- NULL

   interactionsBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
   interactionsBench$Bench <- Bench
   interactionsBench$Filter <- Filter

confusionMatrix(interactionsBench,
                thresholdID = "Pval",
                thresholdValue = 0.05,
                benchCol = "Bench",
                prefilterCol = "Filter",
                statistics = "ConfusionMatrix")
```

## How to visualize reported enhancer-gene associations?

__FUNCTION OF CHOICE: plotInteractions()__

__BACKGROUND__

For user provided enhancer~gene associations (imported as GInteractions) object
plot associations as loops in the context of the genome. 

__IN DETAIL__

Creating a dataset to plot: FTO/IRX3/IRX5 region
```{r}

enhancers <- GRanges(rep("chr16",6),
                      IRanges(c(53112601,55531601,53777201,
                                53778801,54084001,53946467),
                              c(53114200,55533250, 53778800, 
                                53780400, 54084400 ,53947933)))

genes <- GRanges(rep("chr16",6),
                     IRanges(c(53737874, 54964773, 54320676,
                               53737874, 54964773, 54320676),
                             c(53737874, 54964773, 54320676,
                               53737874, 54964773, 54320676)))

GenomeInteractions <- GInteractions(enhancers,genes)

GenomeInteractions$name2 <- c("FTO","IRX5","IRX3")

GenomeInteractions$pval <- c(0.20857403, 0.72856090, 0.03586015,
                             0.32663439, 0.32534945, 0.03994488)

GenomeInteractions$color <- c("red","blue","grey")
 

```

plotInteractions

```{r}
 plotInteractions(interactions = GenomeInteractions,
                  statistics ="pval",
                  coloring = "color")

```

You can choose specific gene to plot: FTO

```{r}
 plotInteractions(interactions = GenomeInteractions,
                        selectGene="FTO")
                  
```

Or choose specific region to plot: chr16:53112601-53114200

NOTE! 
This region does not necessarilly need to be equal to the regulatory 
regions reported in the interactions input objects, whereas it only needs
to overlap some regulatory regions.
```{r}
                   
  plotInteractions(interactions = GenomeInteractions,
               selectRegulatoryRegion = "chr16:53112601-53114200")
```


Additionaly, benchmark datasets can be plotted as well
```{r}
                   
 benchInteractions = list(GenomeInteractions[1:3])

  plotInteractions(interactions = GenomeInteractions,
                         coloring = "color",
                         statistics = "pval",
                         benchInteractions = benchInteractions)
```

# Annotating genomic regions to genes

## How to annotate regulatory regions to genes? 

__FUNCTION OF CHOICE: reg2gene()__

__BACKGROUND__

User can annotate regions of interest (ChIP-Seq peaks or any other genomic 
regions according to the provided enhancer~gene associations object or gene
GRanges object. 

Function either annotates input regions to their nearby genes or it hierarchical
runs annotation procedure (when GIneraction object used as an input provids info about enhancer~gene associations) as follows:
first - annotate to promoters, 
then remaining regions annotate to enhancers,
then remaining regions nearby genes.

__IN DETAIL__

If interactions object is missing, function annotates the input regions to 
their nearby genes. 

When GIneraction object - interactions -  is used as an input, 
then hierarchical association
procedure is runned as follows: promoters,enhancers, nearby genes, eg:
1) genomic regions of interest are first considered to be 
promoters and associated with nearby genes if they are located within a 
certain distance from TSS of nerbay gene (default +/-1000bp); otherwise
2) remaning genomic regions are overlapped with enhancer regions, 
and genes associated to that enhancer regions are reported, 
3) if no overlap with either promoters nor enhancers is identified, then 
closest gene is reported if it is located within 1Mb
4) if no gene located within 1Mb has been identified then, this region is 
filtered out.

IMPORTANT! 
interactions can store info about enhancer~gene interactions, and in that case
Anchor1 in GInteractions object needs to be regulatory region, whereas
anchor2 is the location of gene/TSS.

However, it can store info about interactions regardless whether one anchor of
these interactions correspond to promoters, for example HiC interactions.
In that case set __annotateInteractions=FALSE__ and interactions are firstly 
annotated to the genes (unannotated interactions are removed from the dataset),
and windows are subsequently annotated to genes using annotated interactions 
object.

__Showcase__

Creating toy example:
```{r,echo=FALSE}

# creating toy example
# 1. windows of interest
   windows <- GRanges(c("chr1:1-2", # 1. overlap prom
                                 "chr2:1-2",  # 2. overlap enh
                                 "chr3:1-2", # 3. overlap tss +/- 1,000,000
                                 "chr4:1-2")) # 4. do not overlap tss +/- 1Mb
    
     annotationsEnh <- GRanges(c("chr1:1-2",
                                 "chr2:1-2",
                                 "chr3:100000-100002",
                                 "chr4:10000001-10000002"))
    
     annotationsGenes <- GRanges(c("chr1:1-2",
                                   "chr2:100000-100002",
                                   "chr3:99999-100002",
                                   "chr4:10000001-10000002"))
    
     seqlengths(annotationsEnh) <- seqlengths(annotationsGenes) <- rep(10000002,
                                                                       4)
  # example of interactions
         interactions = GInteractions(annotationsEnh,annotationsGenes,
                                 name=c("gen1","gen2","gen3","gen4"))
     
  # example of geneAnnotations   
     geneAnnotations=second(interactions)
     mcols(geneAnnotations) <- mcols(interactions) 
 
     print("windows of interest")
     windows
      print("toy example of interactions object")
     interactions
      print("toy example of geneAnnotations object")
     geneAnnotations
     
     
```
Running reg2gene annotation function with created toy example:
```{r}     
     
  # run annotation function: 
 reg2gene(windows=windows,
          interactions=interactions, 
          geneAnnotations = geneAnnotations)
 
 # which regions are not identified
 
 reg2gene(windows=windows,
          interactions=interactions, 
          geneAnnotations = geneAnnotations,
          identified=FALSE)
 
 # if interactions are not available, assign interactions based solely on the 
 # proximity to promoters
 reg2gene(windows = windows,
                 interactions=NULL,
                 geneAnnotations = geneAnnotations)
  
```

In addition, if argument identified is set to be FALSE __reg2gene()__
will report genomic regions for which corresponding genes were not identified.

```{r}
 
 reg2gene(windows,
          geneAnnotations=geneAnnotations,
          interactions,
          identified=F)


  

```

---------------------------------------------------------------------------

Additional info:

# Data description 

__GRanges input:__

This package comes with 2 toy datasets, GRanges objects:

GRReg1_toy 

```{r, echo=FALSE}
reg2gene::GRReg1_toy
```
and GRReg2_toy

```{r}
reg2gene::GRReg2_toy
```

with genome locations preselected in such way that all possible outputs
of the  benchmarking procedure is captured. 


*Colums which correspond to the expected outcome of the benchmarking procedure
are: Bench1Exp, Filter2Exp, Bench2Exp, Filter1Exp

Bench1 and Filter1 corresponds to the benchmarking of GRReg1_toy with 
GRReg2_toy, 

whereas Bench2 and Filter2 corresponds to the benchmarking of 
GRReg1_toy with itself.


For example, a following object 
```{r}
reg2gene::GRReg1_toy[7]
```
is benchmarked 3 times with  GRReg2_toy

```{r}
GRReg2_toy[10:12]
```

__.bigWig files as an input__

A second necesarry argument for quantification functions is a named list of 
BigWig file paths is used as an input to link bigwig locations.

As example shows:

```{r}
test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")

regActivityInputExample <- c(test.bw,test2.bw)  

regActivityInputExample

```


__GInteractions objects__

Input data for quantification functions are GRanges objects. 

However, modelling procedure outputs, by default, GInteractions object from the 
InteractionSet package. 

Toy or any other GRanges objects can be easily organized as GInteractions 
objects:

```{r}
  
    GRReg1_toyGI <- GRReg1_toy
    
    GRReg1_toyGI <- GInteractions(GRReg1_toyGI,GRReg1_toyGI$reg)

    GRReg1_toyGI[1:3]

```

---


# Argument description & notes for functions 

## bwToGeneExp() arguments and notes

INPUT DATA DETAIL description (min arguments):
  
__1. exons__

Information about exon and gene coordinates should be a GInteractions object 
from the InteractionSet package, with Anchor1 representing the exon locations, 
and Anchor2 represents location of the corresponding gene. 

```{r,echo=FALSE}

require(InteractionSet)

GRReg1_toyGI <- reg2gene::GRReg1_toy[1]

GRReg1_toyGI <- GInteractions(GRReg1_toyGI,GRReg1_toyGI$reg)

mcols(GRReg1_toyGI) <- mcols(GRReg1_toyGI)[1:3]

GRReg1_toyGI

```

Optionally, the input GRanges object that contains exon regions over which the 
expression will be calculated needs to contain a meta-data columns with the 
following information:
  
  1) reg - GRanges object - corresponding gene location, or TSS location.
2) name (character)- ENSEMBL or other gene identifier; 
3) name2(character,optional) - 2nd gene identifier, 

Example:  
  
```{r,echo=FALSE}

toy <- reg2gene::GRReg1_toy[1]
mcols(toy) <- mcols(toy)[1:3]
toy

```

It is strongly suggested to adjust seqlengths of this object to be equal to 
the seqlenghts *Hsapiens* from the appropriate package
(BSgenome.Hsapiens.UCSC.hg19 or whatever needed version).


__2. target__

A second necesarry argument for quantification functions is a named list 
of BigWig file paths is used as an input to link bigwig locations.

As example shows:
  
```{r}

require(reg2gene)

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")

regActivityInputExample <- c(test.bw,test2.bw)  

regActivityInputExample

```

Additional arguments:
  
  __sampleIDs__ argument

Additional argumets in  bwToGeneExp() adjust for names of RNA-Seq libraries 
(argument __sampleIDs__); whether stranded or/and unstranded libraries are
included, normalization procedure and parallel processing.

For example, __sampleIDs__ by defult uses basenames of the paths for input 
.bigWig files as a unique sample ids/names. However, a vector of unique sample
ids/names(.bw files) can be used as well. It is necessary that values in this
vector are ordered as the .bigWig file paths are.  The previous toy example 
unique sample ids:test and test2 can be modified with the sampleIDs argument
to __CellType__ and __CellType2__ as follows:
  
```{r}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                      c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                              c(1,1,3,5,5,5))


bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw),
            sampleIDs=c("CellType1","CellType2"))


```

__libStrand__ argument

RNA-Seq stranded and unstranded libraries allowed. BUT!!! It is crucial
that forward and reverse RNA-Seq libraries are listed in one on top of other.
For example, 

```{r}

sampleIDs <- c("/Reverse1.bw","/Forward1.bw","/Reverse2.bw","/Forward2.bw",
               "Unstranded1")

sampleIDs
```
needs to be accompanied with 
```{r}
libStrand <- c("+","-","+","-","*")

libStrand

```


__normalize__ 

Normalization procedure in not performed by default but 2 normalizations can
be optionally used:a) __"quantile"__ 
```{r,echo=FALSE}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                      c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                              c(1,1,3,5,5,5))


print("bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw),
      normalize=\"quantile\")")

bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw),
            normalize="quantile")

```
If normalize argument is set to be "quantile" activity measures are 
__quantile normalized__ as implemented in the normalize.quantiles() from 
preprocessCore package.


and b) __"ratio"__

```{r,echo=FALSE}

test.bw <- system.file("extdata", "test.bw",package = "reg2gene")
test2.bw <- system.file("extdata", "test2.bw",package = "reg2gene")
regTSS_toy <- GRanges(c(rep("chr1",2),"chr2",rep("chr1",3)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                      c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3,5,5,5)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                              c(1,1,3,5,5,5))

print("bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw),
      normalize=\"ratio\")")                                  

bwToGeneExp(exons = regTSS_toy,target = c(test.bw,test2.bw),
            normalize="ratio")

```
If normalize argument is set to be"ratio" then __"median ratio method"__ 
implemented as estimateSizeFactorsForMatrix from DESeq2 package is used to
normalize activity measures. 
__NOTE__: Normalization is runned on the level of gene expression. 



__summaryOperation__

This argument designates which summary operation should be used over the regions
Currently, only "mean" is available, but "median" or "sum" will be implemented 
in the future.

__mc.cores__
An option for parallel processing using mclapply from parallel package.



## regActivity() arguments and notes


__min arguments__

To run this function, minimaly windows GRanges object, and a list
of paths to .bigwig files must be used as an input. 


__windows__

windows argument corresponds to a GRanges object which contains regulatory 
regions in the genome over which the regulatory activity will be calculated. It
is strongly suggested to adjust seqlengths of this object to be equal to the
__seqlenghts of Hsapiens__ from the appropriate package
(BSgenome.Hsapiens.UCSC.hg19 or whatever needed version).

Example:
  
```{r,echo=FALSE}

regTSS_toy <- GRanges(c(rep("chr1",4),rep("chr2",2)),
                      IRanges(c(1,7,9,15,1,15),c(4,8,14,20,4,20)),
                      c(rep("+",3),rep("-",3)))
regTSS_toy$reg <-  regTSS_toy[c(1,1,3:6)]
regTSS_toy$name2 <- regTSS_toy$name <- paste0("TEST_Reg",
                                              c(1,1,3:length(regTSS_toy)))


regTSS_toy   

```


__target__

A second necesarry argument for regActivity quantification function is a named 
list of BigWig file paths is used as an input to link bigwig locations. This 
argument corresponds to the __target__ argument in bwToGeneExp(). 

Take a look at the example for this argument at __target__ argument
in bwToGeneExp().


__Other arguments__ 

__sampleIDs__ argument

As in the bwToGeneExp(), this argument adjusts for names of CHiP-Seq libraries.
It by defult uses basenames of the paths for input .bigWig files as a unique 
sample ids/names. However, a vector of unique sample ids/names(.bw files) 
can be used as well. It is necessary that values in this vector are ordered
as the .bigWig file paths are. 
Take a look at the example for this argument at __sampleIDs__ argument in
bwToGeneExp()


__Normalization procedure__

As in the bwToGeneExp(), normalization procedure in not performed by default
but 2 normalizations can be optionally used: __"quantile"__ and __"ratio"__. 
If normalize argument is set to be "quantile" activity measures are
__quantile normalized__ as implemented in the normalize.quantiles()
from preprocessCore package.
If normalize argument is set to be"ratio" then __"median ratio method"__
implemented as estimateSizeFactorsForMatrix from DESeq2 package is used to
normalize activity measures. 

Take a look at the example for this argument at __normalize__ argument in
bwToGeneExp().

__summaryOperation__

As in the bwToGeneExp(), this argument designates which summary operation should
be used over the regions .Currently, only "mean" is available, but "median" or 
"sum" will be implemented in the future.

__mc.cores__

As in the bwToGeneExp(),an option for parallel processing using mclapply from 
parallel package.


__regActivity() specific parameters:__

__isCovNA__ 

This parameter is important when dealing with DNA methylation datasets, 
where uncovered bases in bigWig files do not mean zero methylation. 
When this is set to TRUE, uncovered bases are set to NA.


__weightCol__ 
This parameter is important when genomic regions have scores other than their 
coverage values, such as percent methylation, conservation scores, GC content,
etc.
When used, a numeric column in the meta data is used as weights. 



## regActivityAroundTSS() arguments and notes 

__min arguments:__

__regActivity__

A GRanges object with enhancer locations and quantified enhaner activity need to
be used as an input,the result of the regActivity()

__geneExpression__

A GRanges object with TSSes and meta-columns corresponding to expression 
levels across different cell types or conditions;
an output of the bwToGeneExp()), and __regActivity__ 


__upstream,downstream__

number of basepairs upstream/downstream from TSS to look for regulatory regions. 

__force__

(DEFAULT: FALSE) This argument allows to test input enhancers and genes in
1-to-1 manner. Meaning,a gene expression of gene1 is modelled 
using enhancer1 enhancer activity, gene2 gene expression is modelled with
enhancer2 enhancer activity, etc. Thus, input gene expression GRanges object
(tss) needs to have equal length as enhancer activity GRanges object 
(regActivity). It overwrites upstream and downstream arguments since 1-to-1
relationship is tested. 

```{r, echo=FALSE}

regTSS_toy <- GRReg1_toy
regTSS_toy$bw1 <- rep(1,length(GRReg1_toy))
regTSS_toy$bw2 <- rep(2,length(GRReg1_toy))
regTSS_toy$bw3 <- rep(3,length(GRReg1_toy))
regReg_toy <- GRReg2_toy
regReg_toy$bw1 <- rep(3,length(regReg_toy))
regReg_toy$bw2 <- rep(4,length(regReg_toy))


print("Result of upstream=5,downstream=5")
regActivityAroundTSS(regReg_toy,regTSS_toy,upstream=5,downstream=5)[1]


```

__mc.cores__
As in the bwToGeneExp(),an option for parallel processing using mclapply 
from parallel package.



## associateReg2Gene() arguments and notes



__min arguments__

__Input__

a GRangesList that contains regulatory activity and gene expression 
results. It has to have specific columns, see above example

__method__

Modelling method of choice: pearson,spearman,dcor,elasticnet,
or randomForest. By default it is set to be: "pearson". See Details for more.


__associateReg2Gene() specific arguments:__

__scaleData__

if TRUE (default) the the values for gene expression and regulatory 
activity will be scaled to have 0 mean and unit variance using 
base::scale function.

__mc.cores__
An option for parallel processing using mclapply from parallel package.


__B__
number of randomizations used to estimate P-values for coefficients 
returned by different methods.
default 1000

__asGInteractions__ 

if TRUE (default) results are reported as GInteractions. Otherwise, a GRanges 
object with regulatory region coordinates and an additional column "reg" 
containing gene GRanges is reported: 
```{r, echo=FALSE}

###############################
#STEP 1.  Getting random and predefined .8 correlation

require(GenomicRanges)
require(doMC)
require(glmnet)
require(foreach)
require(stringr)
require(qvalue)

####################################
# create example

x <- c(2.000346,2.166255,0.7372374,0.9380581,2.423209, 
       2.599857,4.216959,2.589133,1.848172,3.039659)
y <- c(2.866875,2.817145,2.1434456,2.9039771,3.819091,5.009990,
       5.048476,2.884551,2.780067,4.053136)
corrM <- rbind(x,y)

# define Granges object
gr0 <- GRanges(seqnames=rep("chr1",2),IRanges(1:2,3:4))

GeneInfo <- as.data.frame(matrix(rep(c("gene","regulatory"),each=3),
                                 ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)

colnames(GeneInfo) <- c("featureType","name","name2")

mcols(gr0) <- DataFrame(cbind(GeneInfo,corrM))

print("associateReg2Gene(gr0,cores = 1,B=100)")
associateReg2Gene(gr0,cores = 1,B=100,asGInteractions=FALSE)     

```


## voteInteractions() arguments and notes

__(min arguments):__

__interactions__	

A list of GInteractions objects outputed from __associateReg2Gene()__ 
or __metaInteractions()__, as shown:
  
```{r, echo=FALSE}
require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
x <- 1:5
y <- 2:6
z <- 10:14
a <- rep(0,length(x))


GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
                                 ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
colnames(GeneInfo) <- c("featureType","name","name2")

mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))

# create associateReg2Gene output objects, GInteractions will all 
# output results

AssocObject <- reg2gene::associateReg2Gene(gr)
AssocObject2 <- reg2gene::associateReg2Gene(gr2)

# input for meta-analysis is list of such objects

interactions <- list(AssocObject,AssocObject2)
names(interactions) <- c("H3K4me1","H327ac")

interactions
```

Since __vote.threshold__ was set to be 0.5, then both gene examples passed
__majority voting__ procedure.

__voteInteractions() specific arguments__

__vote.threshold__

if __vote.threshold__ was set to be a bit higher: 0.51, then gene2 is eliminated
because it was voted for in AssocObject2

```{r, echo=FALSE}

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
x <- 1:5
y <- 2:6
z <- 10:14
a <- rep(0,length(x))


GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
                                 ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
colnames(GeneInfo) <- c("featureType","name","name2")

mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))

# create associateReg2Gene output objects, GInteractions will all 
# output results

AssocObject <- reg2gene::associateReg2Gene(gr)
AssocObject2 <- reg2gene::associateReg2Gene(gr2)

# input for meta-analysis is list of such objects

interactions <- list(AssocObject,AssocObject2)
names(interactions) <- c("H3K4me1","H327ac")

# Run voteInteractions
voteInteractions(interactions, 
                 cutoff.stat="pval",
                 cutoff.val=0.05,
                 vote.threshold=0.51)

```

Thus __vote.threshold__ is a value between 0 and 1, and it designates 
the threshold needed for fraction of votes necessary to retain an association.
As default 0.5: fraction of votes should be greater than or equal to 0.5 to 
retain association.

__cutoff.stat__

Which statistics to filter:"qval" or "pval",...

__cutoff.val__
a numeric cutoff that will be used to filter elements in the 
input list ( __cutoff.stat__ ).
If the input object lacks this column,
every association in the object will be treated as a valid association 
prediction.




## metaInteractions() arguments and notes

__min arguments__

__interactions__

A list of GInteractions objects outputed from __associateReg2Gene()__ as shown:

```{r, echo=FALSE}
# creating datasets

require(GenomicRanges)
require(InteractionSet)

gr2 <- gr <- GRanges(seqnames=rep("chr1",3),IRanges(1:3,3:5))
x <- 1:5
y <- 2:6
z <- 10:14
a <- rep(0,length(x))


GeneInfo <- as.data.frame(matrix(c(rep("gene",3),rep("regulatory",6)),
                                 ncol = 3,byrow = TRUE),stringsAsFactors=FALSE)
colnames(GeneInfo) <- c("featureType","name","name2")

mcols(gr) <- DataFrame(cbind(GeneInfo,rbind(x,y,z)))
mcols(gr2) <- DataFrame(cbind(GeneInfo,rbind(x,y,a)))

# create associateReg2Gene output objects, GInteractions will all 
# output results

AssocObject <- reg2gene::associateReg2Gene(gr)
AssocObject2 <- reg2gene::associateReg2Gene(gr2)

# input for meta-analysis is list of such objects

interactions <- list(AssocObject,AssocObject2)
names(interactions) <- c("Roadmap","Blueprint")

# Run metaA
interactions

```

__specific arguments__

None


## benchmarkInteractions() arguments and notes

An opposite benchmarking example (to the one reported above)
is when anchor1 of the test set 
(__interactions__) overlaps anchor2 of the benchmark set.
Then anchor2 of the test set necessarily needs to overlap anchor1 of the
benchmark set:

```{r, echo=FALSE}

interactions <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[6]
benchInteractions <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[6]

# removing confusing meta-data
mcols(interactions) <- NULL 
mcols(benchInteractions) <- NULL

print("test set:")
interactions

print("benchmark set:")
benchInteractions

print("after benchmarking results in:")
benchmarkInteractions(interactions,
                      benchInteractions,
                      binary=TRUE) 
```

__IMPORTAT NOTE!!!__

If anchor1&anchor2 both overlap only one anchor of the anchor pair in 
the benchmark they are not benchmarked.

However, one need to be careful when benchmarking 
anchors that overlap within the test set (eg enhancer overlaps gene region), 
because they will be benchmarked with 
__benchmarkInteractions()__.

By default Bench column in the output object of the __benchmarkInteractions()__ 
reportes how many times interactions is observed in the benchmark dataset. 

For example, GInteractions pair

chr1 [100, 101] ---      chr1 [102, 103]

can be benchmarked 3 times using following benchmark dataset:
  
```{r, echo=FALSE}
tmp <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]
mcols(tmp) <- NULL
tmp

```
And results in:
```{r, echo=FALSE}

interactions <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[7]
benchInteractions <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]

mcols(interactions) <- NULL

bench <- benchmarkInteractions(interactions,
                               benchInteractions,
                               binary=FALSE) 

bench

```  


However, __benchmarkInteractions()__ can report as well whether
gene~enhancer pair matches some pair in the benchmark dataset or not. 

Then set, argument 

__binary__

to be TRUE.

```{r, echo=FALSE}

interactions <- GInteractions(GRReg1_toy,GRReg1_toy$reg)[7]
benchInteractions <- GInteractions(GRReg2_toy,GRReg2_toy$reg)[10:12]

# removing confusing meta-data
mcols(interactions) <- NULL
mcols(benchInteractions) <- NULL

interactions
benchInteractions

benchmarkInteractions(interactions,
                      benchInteractions,
                      binary=TRUE) 
```  


__minimum arguments__

__interactions__
a GInteractions object to be benchmarked using

__benchInteractions__ 
a second GInteractions object used as benchmark dataset. 
Or a list of GInteractions objects, as follows:
  
```{r}

interactions <- GInteractions(GRReg1_toy,GRReg1_toy$reg)
benchInteractions <- GInteractions(GRReg2_toy,GRReg2_toy$reg)


benchDataList <- list(benchInteractions,interactions)
names(benchDataList) <- c("benchData1","benchData2")


benchmarkInteractions(interactions,
                      benchInteractions=benchDataList,
                      ignore.strand=TRUE,
                      binary=FALSE,
                      nCores = 1)   

```


__specific arguments:__

__mc.cores__

An option for parallel processing using mclapply from parallel package.

__ignore.strand__
is an argument that should be passed to findOverlaps. When set to TRUE, 
the strand information is ignored in the overlap analysis.

__binary__
As mentioned before this is FALSE or TRUE, and defines whether function reports
how many times tested gene~enhancer pair is present in the benchmark dataset;
or whether at all this gene~enhancer pair matches some pair in the benchmark 
dataset or not

__preFilter__ 
(default = FALSE)
If TRUE, additional column Filter is added to the input  object 
(additionally to the Bench column that is reported by default) that store
info whether tested regions have any potential to be benchmarked or not. 
Meaning, if all regulatory region-TSS pairs [anchor1 and anchor2 from reg2Gene] 
do not overlap with any benchmark anchor1 or anchor2 location they will be
reported to be 0 (or no potential to be benchmarked at all), otherwise it is 1 
(possible to be benchmarked). Thus it selects reg2Gene regions only when both 
regulatory region and TSS have overlapping regions somewhere in the benchmarking
set;  but not necessarily overlapping regions of the same benchmark pair. This 
info is important to a priori remove high number of true negatives in 
regulatoryReg-TSS pairs, before running confusionMatrix since TN can be much 
more abundant then TP. 


__forceByName__ 
(default = FALSE)
If TRUE, it forces benchmark data to have an equal gene coordinates as an
input (reg2gene) dataset when gene names overlap. 
IMPORTANT! Gene coordinates are necessarilly a second anchor of the input 
reg2gene and benchInteractions objects, and column with gene names needs to be called 
"name".


## confusionMatrix() arguments and notes


__min arguments__

__interactionsBench__

GInteractions object with added benchmark benchmarkInteractions() and 
OPTIONAL Filter metadata (prior this analysis, it is advised to reduce the 
                          number of true negatives by including only reg2gene entries that could be 
                          potentially benchmarked by setting argument preFilter=TRUE whil running 
                          benchmarkInteractions()).

__thresholdID__

Character (def:NULL), name which indicates a column where statistics of the
modelling procedure is stored: for example: "pval". If not changed to the 
existing column name, then function will return ERROR. This column is filtered
such that everything below predefined threshold is considered to be 
statistically significant association (set to be equal to 0), whereas 
everything above that threshold is 0". Details below.

__statistics__

This function output integer vector or a list. 
If "ConfusionMatrix" is requested then the output is list with following 
elements:__TP__, __FP__, __TN__, __FN__, __Specificity__, __Accuracy__,
__PPV__, __NPV__,__F1__. 


Function reports only PPV if __statistics = "PPV"__  the output is:

```{r, echo=FALSE}
interactionsBench <- GInteractions(GRReg1_toy,GRReg1_toy$reg)

Bench <- interactionsBench$anchor1.Bench1Exp
Filter <- interactionsBench$anchor1.Filter1Exp
mcols(interactionsBench) <- NULL

interactionsBench$Pval <- seq(0, 1, length.out = length(GRReg1_toy))
interactionsBench$Bench <- Bench
interactionsBench$Filter <- Filter

confusionMatrix(interactionsBench,
thresholdID = "Pval",
thresholdValue = 0.05,
benchCol = "Bench",
prefilterCol = "Filter",
statistics = "PPV")
```


__specific arguments__


__benchCol__	

a column name where result of benchmarking procedure is stored.
Default: Bench. A vector of 0's and 1's is expected to be stored in 

__prefilterCol__
a column name where result of filtering procedure is stored (as part of the
benchmarking).
Default: Filter. 
A vector of 0's and 1's is expected to be stored in 

__thresholdValue__

Since __associatereg2Gene()__ reports all input gene-enhancer associations
together with the corresponding test statistics, a threshold for this test 
statistics needs to be set as __thresholdValue__ in __confusionMatrix()__. 
Every gene-enhancer pair with test statistics below __thresholdValue__ will be 
considered to be statistically significant pair - POSITIVE. Otherwise, it is 
consider to be NEGATIVE.
Take a look at an example above.







## plotInteractions() arguments and notes

__min arguments__

__interactions__

A GInteractions object with anchor1 corresponding to 
regulatory region, and anchor2 to the TSS of a gene. Minimum meta-data is 
info about gene names store in column "name2". This object can be produced by 
modelling, or meta-analysis or voting functions from reg2gene package. 
 
__range__ 

(default NULL) this object stores info about gene annotations.
If default, function retrieves automatically gene annotations based on
TxDb.Hsapiens.UCSC.hg19.knownGene package.

Otherwise, this argument corresponds to the range argument from GeneRegionTrack
from Gviz R package, which handles many different data input types:  
TxDb, GRanges, GRangesList,data.frame, character scala. In the case
you want to write your own documentation, for more details about this 
argument take a look at documentation of Gviz package.
 
 __selectGene (default NULL) a character vector of gene name symbols 
 (eg "FTO","IRX3", etc.) which user wants to plot.
 
 __selectRegulatoryRegion__ 
 
 (default NULL) GRanges object or a character vector which stores info about
 the region of interest which user wants to plot
 (format: "chr16:53112601-53114200"). This region does not
 necessarilly need to be equal to the regulatory regions reported in the 
 interactions input objects, whereas it only needs to overlap some
 regulatory regions
 
 __benchInteractions__ 
 
 (default NULL) A GInteractions object or a list of
 GInteractions objects storing info about interaction regions in the genome; 
 for example, regions from the literature obtained using chromatin 
 conformation capture related methods.
 
 __statistics__ 
 
 (default NULL) Column name where info about the heights of 
 loops is stored. If NULL, then all interaction loops have an equal height 
 Otherwise, loops of different height are plotted based on the info stored in
 the corresponding column, eg "pval" or "qval" 
 
 __coloring__
 
 (default NULL) Information about colors used to plot enhancer
 promoter interactions. If it is NULL, then all interactions will be plotted
 red. Otherwise, an ID of the column from interactions object where info 
 about color is stored. For example, interactions for different genes can be 
 colored differently, or statistically significant/insignificant interactions
 can be colored differently. User pre-defines this column by itself.
 
 
__cex.title__
Controls the size of text which describes each track

__plotAllAnchors1__ 
(default FALSE). If interactions argument is a list
 of GInteractions objects, whether to plot all anchor1 or not, eg whether to 
 plot separate track(s) for enhancer regions defined in different tracks, or
 only in one track 

__interactionsNaming__ 
 Track name for the interaction set
 
__benchmarkNaming__ 
Track name for the benchmark interaction set

## reg2gene() arguments and notes


__min arguments__

__windows__ 

GRanges object that contains the windows of interest. It could be enhancers, 
promoters, CpG islands, ChIP-Seq or DNase-Seq peaks...

__geneAnnotations__ 
 GRanges which contains info about genes of interest, or


__interactions__
GInteractions object which stores regulatory regions - gene associations.
Info about gene names should be stored as a meta-data. 

If both objects are available, then input windows are annotated 
to the gene if they are located in the vicinity of the TSS of that genes, and
this info is stored in the input GRanges object.

Otherwise, hierarchical association
of input GRanges object with corresponding genes is performed.

__IMPORTANT!__ 

If GInteractions object is used as an input then, anchor1 needs 
to be regulatory region, whereas anchor2 is location of gene/TSS.

__upstream__

number of basepairs upstream from TSS to look for
input windows. default 1000

__downstream__

number of basepairs downstream from TSS to look for 
input windows. default 1000

__distance__ (default 1Mb). 
Maximal allowed distance between genes TSS and input peaks. 
Used in the 3rd step of the association procedure (genomic regions
is associated to the closest gene if the distance between these two locations
is smaller than prediefined distance threshold.)

__identified__ (default TRUE). 
If TRUE, report genomic regions AND corresponding genes;
If FALSE, report regions for which info about gene is missing.

__annotateInteractions=FALSE__ and interactions are firstly 
annotated to the genes (unannotated interactions are removed from the dataset),
and windows are subsequently annotated to genes using annotated interactions 
object.


# sessionInfo 

```{r, echo=FALSE}
sessionInfo()

```

---

# Short background of the problem

__Enhancers__

Enhancers represent distal regulatory regions in the genome that can be 
located up to 1Mb from the transcription start sites of genes, increase gene 
expression regardless of their position, orientation and distance to the
promoter.

__Enhancer-like chromatin marks__

Different enhancer-like chromatin marks have been previously used to map these
regulatory regions and assess their activity: level of histone modifications
(especially __H3K4me1__ and __H3K27ac__), nucleosome depletion,
__open chromatin accessibility__, __DNA methylation__, nucleotide conservation,
etc. (Mathelier et al., 2015).  
To improve reproducibility of mapping efforts, different chromatin marks were 
integrated in chromatin features (multiple modifications and more complex
elements linked together, Stricker et al. 2017), combined with an unsupervised 
machine-learning approaches and higher number of cell types included in the 
mapping analysis (for example Ernst and Kellis 2012 used ChromHMM Core 15-state 
model and reported more than 900,000 potential enhancer regions across 127 
epigenomes from the Roadmap Epigenomics Project (Kundaje et al. 2015).

__Mapping potential gene targets of an enhancer regions__

1) Mapping of regulatory regions and their targeted genes can be done 
computationally by correlating gene expression with levels of enhancer-
associated chromatin features. Ernst et al. 2011 correlated gene expression 
with different histone modification marks, including enhancer associated marks 
H3K27ac and H3K4me1 (ENCODE Project Consortium 2012), Sheffield et al. 2013 
correlated DNase I Hypersensitivity and gene expression, whereas Varley et al.
2013 was focused on DNA methylation. This package enables easy integration of 
all these datasets.

1) A long-range interactions can be mediated by chromatin looping - a mechanism 
by which enhancers and promoters are brought together in the 3D space of a 
nucleus, which, at least partially, enables precise regulation of gene 
expression (Gorkin et al. 2014, Rennie et al. 2017). Thus information about the 
3D genome architecture, generated by chromosome conformation capture and related
techniques, is can be used as a proxy of enhancer-mediated regulation of gene 
expression or in these case __to benchmark results__ of reg2gene modelling 
approach (Dekker  et al. 2002, Dosie et al. 2006, Simonis et al. 2006, Fullwood 
et al. 2009, Lieberman-Aiden et al. 2009).

---

## Literature


Akalin, Altuna, et al. "Genomation: a toolkit to summarize, annotate and 
visualize genomic intervals." Bioinformatics 31.7 (2014): 1127-1129.

Bolstad, Benjamin Milo. "preprocessCore: A collection of pre-processing 
functions." R package version 1.0 (2013).

Dabney, Alan, John D. Storey, and G. R. Warnes. "qvalue: Q-value estimation 
for false discovery rate control." R package version 1.0 (2010). 

Dekker, Job, et al. "Capturing chromosome conformation." science 295.5558 
(2002): 1306-1311.

Dostie, Jose, et al. "Chromosome Conformation Capture Carbon Copy (5C): 
a massively parallel solution for mapping interactions between genomic elements.
" Genome research 16.10 (2006): 1299-1309. 

ENCODE Project Consortium. "An integrated encyclopedia of DNA elements in 
the human genome." Nature 489.7414 (2012): 57-74.

Ernst, Jason, et al. "Mapping and analysis of chromatin state dynamics in 
nine human cell types." Nature 473.7345 (2011): 43-49.

Ernst, Jason, and Manolis Kellis. "ChromHMM: automating chromatin-state
discovery and characterization." Nature methods 9.3 (2012): 215-216. 

Fullwood, Melissa J., et al. "An oestrogen-receptor--bound human chromatin
interactome." Nature 462.7269 (2009): 58-64.

Gorkin, David U., Danny Leung, and Bing Ren. "The 3D genome in transcriptional
regulation and pluripotency." Cell stem cell 14.6 (2014): 762-775.

Friedman, Jerome, Trevor Hastie, and Rob Tibshirani. "glmnet: Lasso and 
elastic-net regularized generalized linear models." R package version 1.4 (2009).

Kundaje, Anshul, et al. "Integrative analysis of 111 reference human epigenomes.
" Nature 518.7539 (2015): 317-330.

Lieberman-Aiden, Erez, et al. "Comprehensive mapping of long-range interactions
reveals folding principles of the human genome." science 326.5950 (2009): 
289-293.

Lonsdale, John, et al. "The genotype-tissue expression (GTEx) project." Nature
genetics 45.6 (2013): 580-585.

Love, Michael I., Wolfgang Huber, and Simon Anders. "Moderated estimation of 
fold change and dispersion for RNA-seq data with DESeq2." Genome biology 15.12
(2014): 550.

Mathelier, Anthony, Wenqiang Shi, and Wyeth W. Wasserman. "Identification of 
altered cis-regulatory elements in human disease." Trends in Genetics 31.2
(2015): 67-76.

Sheffield, Nathan C., et al. "Patterns of regulatory activity across diverse
human cell types predict tissue identity, transcription factor binding, and 
long-range interactions." Genome research 23.5 (2013): 777-788.

Simonis, Marieke, et al. "Nuclear organization of active and inactive chromatin
domains uncovered by chromosome conformation captureon-chip (4C)." 
Nature genetics 38.11 (2006): 1348-1354.

Stricker, Stefan H., Anna Kferle, and Stephan Beck. "From profiles to function
in epigenomics." Nature Reviews Genetics (2016).

Varley, Katherine E., et al. "Dynamic DNA methylation across diverse human cell 
lines and tissues." Genome research 23.3 (2013): 555-567.

Visel, Axel, et al. "VISTA Enhancer Browsera database of tissue-specific human
enhancers." Nucleic acids research 35.suppl 1 (2007): D88-D92.

Wright, Marvin N., and Andreas Ziegler. "ranger: A fast implementation of random
forests for high dimensional data in C++ and R." arXiv preprint arXiv:1508.04409
(2015).









